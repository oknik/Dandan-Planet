{"version":3,"sources":["index.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\n * Hanzi Writer v3.7.2 | https://chanind.github.io/hanzi-writer\n */\n\n\n\nvar _globalObj$requestAni, _globalObj$cancelAnim, _globalObj$navigator; // hacky way to get around rollup not properly setting `global` to `window` in browser\n\n\nconst globalObj = typeof window === 'undefined' ? global : window;\nconst performanceNow = globalObj.performance && (() => globalObj.performance.now()) || (() => Date.now());\nconst requestAnimationFrame = ((_globalObj$requestAni = globalObj.requestAnimationFrame) === null || _globalObj$requestAni === void 0 ? void 0 : _globalObj$requestAni.bind(globalObj)) || (callback => setTimeout(() => callback(performanceNow()), 1000 / 60));\nconst cancelAnimationFrame = ((_globalObj$cancelAnim = globalObj.cancelAnimationFrame) === null || _globalObj$cancelAnim === void 0 ? void 0 : _globalObj$cancelAnim.bind(globalObj)) || clearTimeout; // Object.assign polyfill, because IE :/\nfunction arrLast(arr) {\n  return arr[arr.length - 1];\n}\nconst fixIndex = (index, length) => {\n  // helper to handle negative indexes in array indices\n  if (index < 0) {\n    return length + index;\n  }\n\n  return index;\n};\nconst selectIndex = (arr, index) => {\n  // helper to select item from array at index, supporting negative indexes\n  return arr[fixIndex(index, arr.length)];\n};\nfunction copyAndMergeDeep(base, override) {\n  const output = { ...base\n  };\n\n  for (const key in override) {\n    const baseVal = base[key];\n    const overrideVal = override[key];\n\n    if (baseVal === overrideVal) {\n      continue;\n    }\n\n    if (baseVal && overrideVal && typeof baseVal === 'object' && typeof overrideVal === 'object' && !Array.isArray(overrideVal)) {\n      output[key] = copyAndMergeDeep(baseVal, overrideVal);\n    } else {\n      // @ts-ignore\n      output[key] = overrideVal;\n    }\n  }\n\n  return output;\n}\n/** basically a simplified version of lodash.get, selects a key out of an object like 'a.b' from {a: {b: 7}} */\n\nfunction inflate(scope, obj) {\n  const parts = scope.split('.');\n  const final = {};\n  let current = final;\n\n  for (let i = 0; i < parts.length; i++) {\n    const cap = i === parts.length - 1 ? obj : {};\n    current[parts[i]] = cap;\n    current = cap;\n  }\n\n  return final;\n}\nlet count = 0;\nfunction counter() {\n  count++;\n  return count;\n}\nfunction average(arr) {\n  const sum = arr.reduce((acc, val) => val + acc, 0);\n  return sum / arr.length;\n}\nfunction colorStringToVals(colorString) {\n  const normalizedColor = colorString.toUpperCase().trim(); // based on https://stackoverflow.com/a/21648508\n\n  if (/^#([A-F0-9]{3}){1,2}$/.test(normalizedColor)) {\n    let hexParts = normalizedColor.substring(1).split('');\n\n    if (hexParts.length === 3) {\n      hexParts = [hexParts[0], hexParts[0], hexParts[1], hexParts[1], hexParts[2], hexParts[2]];\n    }\n\n    const hexStr = `${hexParts.join('')}`;\n    return {\n      r: parseInt(hexStr.slice(0, 2), 16),\n      g: parseInt(hexStr.slice(2, 4), 16),\n      b: parseInt(hexStr.slice(4, 6), 16),\n      a: 1\n    };\n  }\n\n  const rgbMatch = normalizedColor.match(/^RGBA?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d*\\.?\\d+))?\\)$/);\n\n  if (rgbMatch) {\n    return {\n      r: parseInt(rgbMatch[1], 10),\n      g: parseInt(rgbMatch[2], 10),\n      b: parseInt(rgbMatch[3], 10),\n      // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.\n      a: parseFloat(rgbMatch[4] || 1, 10)\n    };\n  }\n\n  throw new Error(`Invalid color: ${colorString}`);\n}\nconst trim = string => string.replace(/^\\s+/, '').replace(/\\s+$/, ''); // return a new array-like object with int keys where each key is item\n// ex: objRepeat({x: 8}, 3) === {0: {x: 8}, 1: {x: 8}, 2: {x: 8}}\n\nfunction objRepeat(item, times) {\n  const obj = {};\n\n  for (let i = 0; i < times; i++) {\n    obj[i] = item;\n  }\n\n  return obj;\n} // similar to objRepeat, but takes in a callback which is called for each index in the object\n\nfunction objRepeatCb(times, cb) {\n  const obj = {};\n\n  for (let i = 0; i < times; i++) {\n    obj[i] = cb(i);\n  }\n\n  return obj;\n}\nconst ua = ((_globalObj$navigator = globalObj.navigator) === null || _globalObj$navigator === void 0 ? void 0 : _globalObj$navigator.userAgent) || '';\nconst isMsBrowser = ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0; // eslint-disable-next-line @typescript-eslint/no-empty-function\n\nconst noop = () => {};\n\nclass RenderState {\n  constructor(character, options, onStateChange = noop) {\n    this._mutationChains = [];\n    this._onStateChange = onStateChange;\n    this.state = {\n      options: {\n        drawingFadeDuration: options.drawingFadeDuration,\n        drawingWidth: options.drawingWidth,\n        drawingColor: colorStringToVals(options.drawingColor),\n        strokeColor: colorStringToVals(options.strokeColor),\n        outlineColor: colorStringToVals(options.outlineColor),\n        radicalColor: colorStringToVals(options.radicalColor || options.strokeColor),\n        highlightColor: colorStringToVals(options.highlightColor)\n      },\n      character: {\n        main: {\n          opacity: options.showCharacter ? 1 : 0,\n          strokes: {}\n        },\n        outline: {\n          opacity: options.showOutline ? 1 : 0,\n          strokes: {}\n        },\n        highlight: {\n          opacity: 1,\n          strokes: {}\n        }\n      },\n      userStrokes: null\n    };\n\n    for (let i = 0; i < character.strokes.length; i++) {\n      this.state.character.main.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1\n      };\n      this.state.character.outline.strokes[i] = {\n        opacity: 1,\n        displayPortion: 1\n      };\n      this.state.character.highlight.strokes[i] = {\n        opacity: 0,\n        displayPortion: 1\n      };\n    }\n  }\n\n  overwriteOnStateChange(onStateChange) {\n    this._onStateChange = onStateChange;\n  }\n\n  updateState(stateChanges) {\n    const nextState = copyAndMergeDeep(this.state, stateChanges);\n\n    this._onStateChange(nextState, this.state);\n\n    this.state = nextState;\n  }\n\n  run(mutations, options = {}) {\n    const scopes = mutations.map(mut => mut.scope);\n    this.cancelMutations(scopes);\n    return new Promise(resolve => {\n      const mutationChain = {\n        _isActive: true,\n        _index: 0,\n        _resolve: resolve,\n        _mutations: mutations,\n        _loop: options.loop,\n        _scopes: scopes\n      };\n\n      this._mutationChains.push(mutationChain);\n\n      this._run(mutationChain);\n    });\n  }\n\n  _run(mutationChain) {\n    if (!mutationChain._isActive) {\n      return;\n    }\n\n    const mutations = mutationChain._mutations;\n\n    if (mutationChain._index >= mutations.length) {\n      if (mutationChain._loop) {\n        mutationChain._index = 0; // eslint-disable-line no-param-reassign\n      } else {\n        mutationChain._isActive = false; // eslint-disable-line no-param-reassign\n\n        this._mutationChains = this._mutationChains.filter(chain => chain !== mutationChain); // The chain is done - resolve the promise to signal it finished successfully\n\n        mutationChain._resolve({\n          canceled: false\n        });\n\n        return;\n      }\n    }\n\n    const activeMutation = mutationChain._mutations[mutationChain._index];\n    activeMutation.run(this).then(() => {\n      if (mutationChain._isActive) {\n        mutationChain._index++; // eslint-disable-line no-param-reassign\n\n        this._run(mutationChain);\n      }\n    });\n  }\n\n  _getActiveMutations() {\n    return this._mutationChains.map(chain => chain._mutations[chain._index]);\n  }\n\n  pauseAll() {\n    this._getActiveMutations().forEach(mutation => mutation.pause());\n  }\n\n  resumeAll() {\n    this._getActiveMutations().forEach(mutation => mutation.resume());\n  }\n\n  cancelMutations(scopesToCancel) {\n    for (const chain of this._mutationChains) {\n      for (const chainId of chain._scopes) {\n        for (const scopeToCancel of scopesToCancel) {\n          if (chainId.startsWith(scopeToCancel) || scopeToCancel.startsWith(chainId)) {\n            this._cancelMutationChain(chain);\n          }\n        }\n      }\n    }\n  }\n\n  cancelAll() {\n    this.cancelMutations(['']);\n  }\n\n  _cancelMutationChain(mutationChain) {\n    var _mutationChain$_resol;\n\n    mutationChain._isActive = false;\n\n    for (let i = mutationChain._index; i < mutationChain._mutations.length; i++) {\n      mutationChain._mutations[i].cancel(this);\n    }\n\n    (_mutationChain$_resol = mutationChain._resolve) === null || _mutationChain$_resol === void 0 ? void 0 : _mutationChain$_resol.call(mutationChain, {\n      canceled: true\n    });\n    this._mutationChains = this._mutationChains.filter(chain => chain !== mutationChain);\n  }\n\n}\n\nconst subtract = (p1, p2) => ({\n  x: p1.x - p2.x,\n  y: p1.y - p2.y\n});\nconst magnitude = point => Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\nconst distance = (point1, point2) => magnitude(subtract(point1, point2));\nconst equals = (point1, point2) => point1.x === point2.x && point1.y === point2.y;\nconst round = (point, precision = 1) => {\n  const multiplier = precision * 10;\n  return {\n    x: Math.round(multiplier * point.x) / multiplier,\n    y: Math.round(multiplier * point.y) / multiplier\n  };\n};\nconst length = points => {\n  let lastPoint = points[0];\n  const pointsSansFirst = points.slice(1);\n  return pointsSansFirst.reduce((acc, point) => {\n    const dist = distance(point, lastPoint);\n    lastPoint = point;\n    return acc + dist;\n  }, 0);\n};\nconst cosineSimilarity = (point1, point2) => {\n  const rawDotProduct = point1.x * point2.x + point1.y * point2.y;\n  return rawDotProduct / magnitude(point1) / magnitude(point2);\n};\n/**\n * return a new point, p3, which is on the same line as p1 and p2, but distance away\n * from p2. p1, p2, p3 will always lie on the line in that order\n */\n\nconst _extendPointOnLine = (p1, p2, dist) => {\n  const vect = subtract(p2, p1);\n  const norm = dist / magnitude(vect);\n  return {\n    x: p2.x + norm * vect.x,\n    y: p2.y + norm * vect.y\n  };\n};\n/** based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf */\n\nconst frechetDist = (curve1, curve2) => {\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\n\n  const calcVal = (i, j, prevResultsCol, curResultsCol) => {\n    if (i === 0 && j === 0) {\n      return distance(longCurve[0], shortCurve[0]);\n    }\n\n    if (i > 0 && j === 0) {\n      return Math.max(prevResultsCol[0], distance(longCurve[i], shortCurve[0]));\n    }\n\n    const lastResult = curResultsCol[curResultsCol.length - 1];\n\n    if (i === 0 && j > 0) {\n      return Math.max(lastResult, distance(longCurve[0], shortCurve[j]));\n    }\n\n    return Math.max(Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult), distance(longCurve[i], shortCurve[j]));\n  };\n\n  let prevResultsCol = [];\n\n  for (let i = 0; i < longCurve.length; i++) {\n    const curResultsCol = [];\n\n    for (let j = 0; j < shortCurve.length; j++) {\n      // we only need the results from i - 1 and j - 1 to continue the calculation\n      // so we only need to hold onto the last column of calculated results\n      // prevResultsCol is results[i-1][:] in the original algorithm\n      // curResultsCol is results[i][:j-1] in the original algorithm\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\n    }\n\n    prevResultsCol = curResultsCol;\n  }\n\n  return prevResultsCol[shortCurve.length - 1];\n};\n/** break up long segments in the curve into smaller segments of len maxLen or smaller */\n\nconst subdivideCurve = (curve, maxLen = 0.05) => {\n  const newCurve = curve.slice(0, 1);\n\n  for (const point of curve.slice(1)) {\n    const prevPoint = newCurve[newCurve.length - 1];\n    const segLen = distance(point, prevPoint);\n\n    if (segLen > maxLen) {\n      const numNewPoints = Math.ceil(segLen / maxLen);\n      const newSegLen = segLen / numNewPoints;\n\n      for (let i = 0; i < numNewPoints; i++) {\n        newCurve.push(_extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));\n      }\n    } else {\n      newCurve.push(point);\n    }\n  }\n\n  return newCurve;\n};\n/** redraw the curve using numPoints equally spaced out along the length of the curve */\n\nconst outlineCurve = (curve, numPoints = 30) => {\n  const curveLen = length(curve);\n  const segmentLen = curveLen / (numPoints - 1);\n  const outlinePoints = [curve[0]];\n  const endPoint = arrLast(curve);\n  const remainingCurvePoints = curve.slice(1);\n\n  for (let i = 0; i < numPoints - 2; i++) {\n    let lastPoint = arrLast(outlinePoints);\n    let remainingDist = segmentLen;\n    let outlinePointFound = false;\n\n    while (!outlinePointFound) {\n      const nextPointDist = distance(lastPoint, remainingCurvePoints[0]);\n\n      if (nextPointDist < remainingDist) {\n        remainingDist -= nextPointDist;\n        lastPoint = remainingCurvePoints.shift();\n      } else {\n        const nextPoint = _extendPointOnLine(lastPoint, remainingCurvePoints[0], remainingDist - nextPointDist);\n\n        outlinePoints.push(nextPoint);\n        outlinePointFound = true;\n      }\n    }\n  }\n\n  outlinePoints.push(endPoint);\n  return outlinePoints;\n};\n/** translate and scale from https://en.wikipedia.org/wiki/Procrustes_analysis */\n\nconst normalizeCurve = curve => {\n  const outlinedCurve = outlineCurve(curve);\n  const meanX = average(outlinedCurve.map(point => point.x));\n  const meanY = average(outlinedCurve.map(point => point.y));\n  const mean = {\n    x: meanX,\n    y: meanY\n  };\n  const translatedCurve = outlinedCurve.map(point => subtract(point, mean));\n  const scale = Math.sqrt(average([Math.pow(translatedCurve[0].x, 2) + Math.pow(translatedCurve[0].y, 2), Math.pow(arrLast(translatedCurve).x, 2) + Math.pow(arrLast(translatedCurve).y, 2)]));\n  const scaledCurve = translatedCurve.map(point => ({\n    x: point.x / scale,\n    y: point.y / scale\n  }));\n  return subdivideCurve(scaledCurve);\n}; // rotate around the origin\n\nconst rotate = (curve, theta) => {\n  return curve.map(point => ({\n    x: Math.cos(theta) * point.x - Math.sin(theta) * point.y,\n    y: Math.sin(theta) * point.x + Math.cos(theta) * point.y\n  }));\n}; // remove intermediate points that are on the same line as the points to either side\n\nconst _filterParallelPoints = points => {\n  if (points.length < 3) return points;\n  const filteredPoints = [points[0], points[1]];\n  points.slice(2).forEach(point => {\n    const numFilteredPoints = filteredPoints.length;\n    const curVect = subtract(point, filteredPoints[numFilteredPoints - 1]);\n    const prevVect = subtract(filteredPoints[numFilteredPoints - 1], filteredPoints[numFilteredPoints - 2]); // this is the z coord of the cross-product. If this is 0 then they're parallel\n\n    const isParallel = curVect.y * prevVect.x - curVect.x * prevVect.y === 0;\n\n    if (isParallel) {\n      filteredPoints.pop();\n    }\n\n    filteredPoints.push(point);\n  });\n  return filteredPoints;\n};\nfunction getPathString(points, close = false) {\n  const start = round(points[0]);\n  const remainingPoints = points.slice(1);\n  let pathString = `M ${start.x} ${start.y}`;\n  remainingPoints.forEach(point => {\n    const roundedPoint = round(point);\n    pathString += ` L ${roundedPoint.x} ${roundedPoint.y}`;\n  });\n\n  if (close) {\n    pathString += 'Z';\n  }\n\n  return pathString;\n}\n/** take points on a path and move their start point backwards by distance */\n\nconst extendStart = (points, dist) => {\n  const filteredPoints = _filterParallelPoints(points);\n\n  if (filteredPoints.length < 2) return filteredPoints;\n  const p1 = filteredPoints[1];\n  const p2 = filteredPoints[0];\n\n  const newStart = _extendPointOnLine(p1, p2, dist);\n\n  const extendedPoints = filteredPoints.slice(1);\n  extendedPoints.unshift(newStart);\n  return extendedPoints;\n};\n\nclass Stroke {\n  constructor(path, points, strokeNum, isInRadical = false) {\n    this.path = path;\n    this.points = points;\n    this.strokeNum = strokeNum;\n    this.isInRadical = isInRadical;\n  }\n\n  getStartingPoint() {\n    return this.points[0];\n  }\n\n  getEndingPoint() {\n    return this.points[this.points.length - 1];\n  }\n\n  getLength() {\n    return length(this.points);\n  }\n\n  getVectors() {\n    let lastPoint = this.points[0];\n    const pointsSansFirst = this.points.slice(1);\n    return pointsSansFirst.map(point => {\n      const vector = subtract(point, lastPoint);\n      lastPoint = point;\n      return vector;\n    });\n  }\n\n  getDistance(point) {\n    const distances = this.points.map(strokePoint => distance(strokePoint, point));\n    return Math.min(...distances);\n  }\n\n  getAverageDistance(points) {\n    const totalDist = points.reduce((acc, point) => acc + this.getDistance(point), 0);\n    return totalDist / points.length;\n  }\n\n}\n\nclass Character {\n  constructor(symbol, strokes) {\n    this.symbol = symbol;\n    this.strokes = strokes;\n  }\n\n}\n\nfunction generateStrokes({\n  radStrokes,\n  strokes,\n  medians\n}) {\n  const isInRadical = strokeNum => {\n    var _radStrokes$indexOf;\n\n    return ((_radStrokes$indexOf = radStrokes === null || radStrokes === void 0 ? void 0 : radStrokes.indexOf(strokeNum)) !== null && _radStrokes$indexOf !== void 0 ? _radStrokes$indexOf : -1) >= 0;\n  };\n\n  return strokes.map((path, index) => {\n    const points = medians[index].map(pointData => {\n      const [x, y] = pointData;\n      return {\n        x,\n        y\n      };\n    });\n    return new Stroke(path, points, index, isInRadical(index));\n  });\n}\n\nfunction parseCharData(symbol, charJson) {\n  const strokes = generateStrokes(charJson);\n  return new Character(symbol, strokes);\n}\n\n// All makemeahanzi characters have the same bounding box\nconst CHARACTER_BOUNDS = [{\n  x: 0,\n  y: -124\n}, {\n  x: 1024,\n  y: 900\n}];\nconst [from, to] = CHARACTER_BOUNDS;\nconst preScaledWidth = to.x - from.x;\nconst preScaledHeight = to.y - from.y;\nclass Positioner {\n  constructor(options) {\n    const {\n      padding,\n      width,\n      height\n    } = options;\n    this.padding = padding;\n    this.width = width;\n    this.height = height;\n    const effectiveWidth = width - 2 * padding;\n    const effectiveHeight = height - 2 * padding;\n    const scaleX = effectiveWidth / preScaledWidth;\n    const scaleY = effectiveHeight / preScaledHeight;\n    this.scale = Math.min(scaleX, scaleY);\n    const xCenteringBuffer = padding + (effectiveWidth - this.scale * preScaledWidth) / 2;\n    const yCenteringBuffer = padding + (effectiveHeight - this.scale * preScaledHeight) / 2;\n    this.xOffset = -1 * from.x * this.scale + xCenteringBuffer;\n    this.yOffset = -1 * from.y * this.scale + yCenteringBuffer;\n  }\n\n  convertExternalPoint(point) {\n    const x = (point.x - this.xOffset) / this.scale;\n    const y = (this.height - this.yOffset - point.y) / this.scale;\n    return {\n      x,\n      y\n    };\n  }\n\n}\n\nconst COSINE_SIMILARITY_THRESHOLD = 0; // -1 to 1, smaller = more lenient\n\nconst START_AND_END_DIST_THRESHOLD = 250; // bigger = more lenient\n\nconst FRECHET_THRESHOLD = 0.4; // bigger = more lenient\n\nconst MIN_LEN_THRESHOLD = 0.35; // smaller = more lenient\n\nfunction strokeMatches(userStroke, character, strokeNum, options = {}) {\n  const strokes = character.strokes;\n  const points = stripDuplicates(userStroke.points);\n\n  if (points.length < 2) {\n    return {\n      isMatch: false,\n      meta: {\n        isStrokeBackwards: false\n      }\n    };\n  }\n\n  const {\n    isMatch,\n    meta,\n    avgDist\n  } = getMatchData(points, strokes[strokeNum], options);\n\n  if (!isMatch) {\n    return {\n      isMatch,\n      meta\n    };\n  } // if there is a better match among strokes the user hasn't drawn yet, the user probably drew the wrong stroke\n\n\n  const laterStrokes = strokes.slice(strokeNum + 1);\n  let closestMatchDist = avgDist;\n\n  for (let i = 0; i < laterStrokes.length; i++) {\n    const {\n      isMatch,\n      avgDist\n    } = getMatchData(points, laterStrokes[i], { ...options,\n      checkBackwards: false\n    });\n\n    if (isMatch && avgDist < closestMatchDist) {\n      closestMatchDist = avgDist;\n    }\n  } // if there's a better match, rather that returning false automatically, try reducing leniency instead\n  // if leniency is already really high we can allow some similar strokes to pass\n\n\n  if (closestMatchDist < avgDist) {\n    // adjust leniency between 0.3 and 0.6 depending on how much of a better match the new match is\n    const leniencyAdjustment = 0.6 * (closestMatchDist + avgDist) / (2 * avgDist);\n    const {\n      isMatch,\n      meta\n    } = getMatchData(points, strokes[strokeNum], { ...options,\n      leniency: (options.leniency || 1) * leniencyAdjustment\n    });\n    return {\n      isMatch,\n      meta\n    };\n  }\n\n  return {\n    isMatch,\n    meta\n  };\n}\n\nconst startAndEndMatches = (points, closestStroke, leniency) => {\n  const startingDist = distance(closestStroke.getStartingPoint(), points[0]);\n  const endingDist = distance(closestStroke.getEndingPoint(), points[points.length - 1]);\n  return startingDist <= START_AND_END_DIST_THRESHOLD * leniency && endingDist <= START_AND_END_DIST_THRESHOLD * leniency;\n}; // returns a list of the direction of all segments in the line connecting the points\n\n\nconst getEdgeVectors = points => {\n  const vectors = [];\n  let lastPoint = points[0];\n  points.slice(1).forEach(point => {\n    vectors.push(subtract(point, lastPoint));\n    lastPoint = point;\n  });\n  return vectors;\n};\n\nconst directionMatches = (points, stroke) => {\n  const edgeVectors = getEdgeVectors(points);\n  const strokeVectors = stroke.getVectors();\n  const similarities = edgeVectors.map(edgeVector => {\n    const strokeSimilarities = strokeVectors.map(strokeVector => cosineSimilarity(strokeVector, edgeVector));\n    return Math.max(...strokeSimilarities);\n  });\n  const avgSimilarity = average(similarities);\n  return avgSimilarity > COSINE_SIMILARITY_THRESHOLD;\n};\n\nconst lengthMatches = (points, stroke, leniency) => {\n  return leniency * (length(points) + 25) / (stroke.getLength() + 25) >= MIN_LEN_THRESHOLD;\n};\n\nconst stripDuplicates = points => {\n  if (points.length < 2) return points;\n  const [firstPoint, ...rest] = points;\n  const dedupedPoints = [firstPoint];\n\n  for (const point of rest) {\n    if (!equals(point, dedupedPoints[dedupedPoints.length - 1])) {\n      dedupedPoints.push(point);\n    }\n  }\n\n  return dedupedPoints;\n};\n\nconst SHAPE_FIT_ROTATIONS = [Math.PI / 16, Math.PI / 32, 0, -1 * Math.PI / 32, -1 * Math.PI / 16];\n\nconst shapeFit = (curve1, curve2, leniency) => {\n  const normCurve1 = normalizeCurve(curve1);\n  const normCurve2 = normalizeCurve(curve2);\n  let minDist = Infinity;\n  SHAPE_FIT_ROTATIONS.forEach(theta => {\n    const dist = frechetDist(normCurve1, rotate(normCurve2, theta));\n\n    if (dist < minDist) {\n      minDist = dist;\n    }\n  });\n  return minDist <= FRECHET_THRESHOLD * leniency;\n};\n\nconst getMatchData = (points, stroke, options) => {\n  const {\n    leniency = 1,\n    isOutlineVisible = false,\n    checkBackwards = true,\n    averageDistanceThreshold = 350\n  } = options;\n  const avgDist = stroke.getAverageDistance(points);\n  const distMod = isOutlineVisible || stroke.strokeNum > 0 ? 0.5 : 1;\n  const withinDistThresh = avgDist <= averageDistanceThreshold * distMod * leniency; // short circuit for faster matching\n\n  if (!withinDistThresh) {\n    return {\n      isMatch: false,\n      avgDist,\n      meta: {\n        isStrokeBackwards: false\n      }\n    };\n  }\n\n  const startAndEndMatch = startAndEndMatches(points, stroke, leniency);\n  const directionMatch = directionMatches(points, stroke);\n  const shapeMatch = shapeFit(points, stroke.points, leniency);\n  const lengthMatch = lengthMatches(points, stroke, leniency);\n  const isMatch = withinDistThresh && startAndEndMatch && directionMatch && shapeMatch && lengthMatch;\n\n  if (checkBackwards && !isMatch) {\n    const backwardsMatchData = getMatchData([...points].reverse(), stroke, { ...options,\n      checkBackwards: false\n    });\n\n    if (backwardsMatchData.isMatch) {\n      return {\n        isMatch,\n        avgDist,\n        meta: {\n          isStrokeBackwards: true\n        }\n      };\n    }\n  }\n\n  return {\n    isMatch,\n    avgDist,\n    meta: {\n      isStrokeBackwards: false\n    }\n  };\n};\n\nclass UserStroke {\n  constructor(id, startingPoint, startingExternalPoint) {\n    this.id = id;\n    this.points = [startingPoint];\n    this.externalPoints = [startingExternalPoint];\n  }\n\n  appendPoint(point, externalPoint) {\n    this.points.push(point);\n    this.externalPoints.push(externalPoint);\n  }\n\n}\n\nclass Delay {\n  constructor(duration) {\n    this._duration = duration;\n    this._startTime = null;\n    this._paused = false;\n    this.scope = `delay.${duration}`;\n  }\n\n  run() {\n    this._startTime = performanceNow();\n    this._runningPromise = new Promise(resolve => {\n      this._resolve = resolve; // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n\n      this._timeout = setTimeout(() => this.cancel(), this._duration);\n    });\n    return this._runningPromise;\n  }\n\n  pause() {\n    if (this._paused) return; // to pause, clear the timeout and rewrite this._duration with whatever time is remaining\n\n    const elapsedDelay = performance.now() - (this._startTime || 0);\n    this._duration = Math.max(0, this._duration - elapsedDelay);\n    clearTimeout(this._timeout);\n    this._paused = true;\n  }\n\n  resume() {\n    if (!this._paused) return;\n    this._startTime = performance.now(); // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\n\n    this._timeout = setTimeout(() => this.cancel(), this._duration);\n    this._paused = false;\n  }\n\n  cancel() {\n    clearTimeout(this._timeout);\n\n    if (this._resolve) {\n      this._resolve();\n    }\n\n    this._resolve = undefined;\n  }\n\n}\n\nclass Mutation {\n  /**\n   *\n   * @param scope a string representation of what fields this mutation affects from the state. This is used to cancel conflicting mutations\n   * @param valuesOrCallable a thunk containing the value to set, or a callback which will return those values\n   */\n  constructor(scope, valuesOrCallable, options = {}) {\n    this._tick = timing => {\n      if (this._startPauseTime !== null) {\n        return;\n      }\n\n      const progress = Math.min(1, (timing - this._startTime - this._pausedDuration) / this._duration);\n\n      if (progress === 1) {\n        this._renderState.updateState(this._values);\n\n        this._frameHandle = undefined;\n        this.cancel(this._renderState);\n      } else {\n        const easedProgress = ease(progress);\n        const stateChanges = getPartialValues(this._startState, this._values, easedProgress);\n\n        this._renderState.updateState(stateChanges);\n\n        this._frameHandle = requestAnimationFrame(this._tick);\n      }\n    };\n\n    this.scope = scope;\n    this._valuesOrCallable = valuesOrCallable;\n    this._duration = options.duration || 0;\n    this._force = options.force;\n    this._pausedDuration = 0;\n    this._startPauseTime = null;\n  }\n\n  run(renderState) {\n    if (!this._values) this._inflateValues(renderState);\n    if (this._duration === 0) renderState.updateState(this._values);\n\n    if (this._duration === 0 || isAlreadyAtEnd(renderState.state, this._values)) {\n      return Promise.resolve();\n    }\n\n    this._renderState = renderState;\n    this._startState = renderState.state;\n    this._startTime = performance.now();\n    this._frameHandle = requestAnimationFrame(this._tick);\n    return new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  _inflateValues(renderState) {\n    let values = this._valuesOrCallable;\n\n    if (typeof this._valuesOrCallable === 'function') {\n      values = this._valuesOrCallable(renderState.state);\n    }\n\n    this._values = inflate(this.scope, values);\n  }\n\n  pause() {\n    if (this._startPauseTime !== null) {\n      return;\n    }\n\n    if (this._frameHandle) {\n      cancelAnimationFrame(this._frameHandle);\n    }\n\n    this._startPauseTime = performance.now();\n  }\n\n  resume() {\n    if (this._startPauseTime === null) {\n      return;\n    }\n\n    this._frameHandle = requestAnimationFrame(this._tick);\n    this._pausedDuration += performance.now() - this._startPauseTime;\n    this._startPauseTime = null;\n  }\n\n  cancel(renderState) {\n    var _this$_resolve;\n\n    (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this);\n    this._resolve = undefined;\n    cancelAnimationFrame(this._frameHandle || -1);\n    this._frameHandle = undefined;\n\n    if (this._force) {\n      if (!this._values) this._inflateValues(renderState);\n      renderState.updateState(this._values);\n    }\n  }\n\n}\nMutation.Delay = Delay;\n\nfunction getPartialValues(startValues, endValues, progress) {\n  const target = {};\n\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\n\n    if (typeof startValue === 'number' && typeof endValue === 'number' && endValue >= 0) {\n      target[key] = progress * (endValue - startValue) + startValue;\n    } else {\n      target[key] = getPartialValues(startValue, endValue, progress);\n    }\n  }\n\n  return target;\n}\n\nfunction isAlreadyAtEnd(startValues, endValues) {\n  for (const key in endValues) {\n    const endValue = endValues[key];\n    const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\n\n    if (endValue >= 0) {\n      if (endValue !== startValue) {\n        return false;\n      }\n    } else if (!isAlreadyAtEnd(startValue, endValue)) {\n      return false;\n    }\n  }\n\n  return true;\n} // from https://github.com/maxwellito/vivus\n\n\nconst ease = x => -Math.cos(x * Math.PI) / 2 + 0.5;\n\nconst showStrokes = (charName, character, duration) => {\n  return [new Mutation(`character.${charName}.strokes`, objRepeat({\n    opacity: 1,\n    displayPortion: 1\n  }, character.strokes.length), {\n    duration,\n    force: true\n  })];\n};\nconst showCharacter = (charName, character, duration) => {\n  return [new Mutation(`character.${charName}`, {\n    opacity: 1,\n    strokes: objRepeat({\n      opacity: 1,\n      displayPortion: 1\n    }, character.strokes.length)\n  }, {\n    duration,\n    force: true\n  })];\n};\nconst hideCharacter = (charName, character, duration) => {\n  return [new Mutation(`character.${charName}.opacity`, 0, {\n    duration,\n    force: true\n  }), ...showStrokes(charName, character, 0)];\n};\nconst updateColor = (colorName, colorVal, duration) => {\n  return [new Mutation(`options.${colorName}`, colorVal, {\n    duration\n  })];\n};\nconst highlightStroke = (stroke, color, speed) => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [new Mutation('options.highlightColor', color), new Mutation('character.highlight', {\n    opacity: 1,\n    strokes: {\n      [strokeNum]: {\n        displayPortion: 0,\n        opacity: 0\n      }\n    }\n  }), new Mutation(`character.highlight.strokes.${strokeNum}`, {\n    displayPortion: 1,\n    opacity: 1\n  }, {\n    duration\n  }), new Mutation(`character.highlight.strokes.${strokeNum}.opacity`, 0, {\n    duration,\n    force: true\n  })];\n};\nconst animateStroke = (charName, stroke, speed) => {\n  const strokeNum = stroke.strokeNum;\n  const duration = (stroke.getLength() + 600) / (3 * speed);\n  return [new Mutation(`character.${charName}`, {\n    opacity: 1,\n    strokes: {\n      [strokeNum]: {\n        displayPortion: 0,\n        opacity: 1\n      }\n    }\n  }), new Mutation(`character.${charName}.strokes.${strokeNum}.displayPortion`, 1, {\n    duration\n  })];\n};\nconst animateSingleStroke = (charName, character, strokeNum, speed) => {\n  const mutationStateFunc = state => {\n    const curCharState = state.character[charName];\n    const mutationState = {\n      opacity: 1,\n      strokes: {}\n    };\n\n    for (let i = 0; i < character.strokes.length; i++) {\n      mutationState.strokes[i] = {\n        opacity: curCharState.opacity * curCharState.strokes[i].opacity\n      };\n    }\n\n    return mutationState;\n  };\n\n  const stroke = character.strokes[strokeNum];\n  return [new Mutation(`character.${charName}`, mutationStateFunc), ...animateStroke(charName, stroke, speed)];\n};\nconst showStroke = (charName, strokeNum, duration) => {\n  return [new Mutation(`character.${charName}.strokes.${strokeNum}`, {\n    displayPortion: 1,\n    opacity: 1\n  }, {\n    duration,\n    force: true\n  })];\n};\nconst animateCharacter = (charName, character, fadeDuration, speed, delayBetweenStrokes) => {\n  let mutations = hideCharacter(charName, character, fadeDuration);\n  mutations = mutations.concat(showStrokes(charName, character, 0));\n  mutations.push(new Mutation(`character.${charName}`, {\n    opacity: 1,\n    strokes: objRepeat({\n      opacity: 0\n    }, character.strokes.length)\n  }, {\n    force: true\n  }));\n  character.strokes.forEach((stroke, i) => {\n    if (i > 0) mutations.push(new Mutation.Delay(delayBetweenStrokes));\n    mutations = mutations.concat(animateStroke(charName, stroke, speed));\n  });\n  return mutations;\n};\nconst animateCharacterLoop = (charName, character, fadeDuration, speed, delayBetweenStrokes, delayBetweenLoops) => {\n  const mutations = animateCharacter(charName, character, fadeDuration, speed, delayBetweenStrokes);\n  mutations.push(new Mutation.Delay(delayBetweenLoops));\n  return mutations;\n};\n\nconst startQuiz = (character, fadeDuration, startStrokeNum) => {\n  return [...hideCharacter('main', character, fadeDuration), new Mutation('character.highlight', {\n    opacity: 1,\n    strokes: objRepeat({\n      opacity: 0\n    }, character.strokes.length)\n  }, {\n    force: true\n  }), new Mutation('character.main', {\n    opacity: 1,\n    strokes: objRepeatCb(character.strokes.length, i => ({\n      opacity: i < startStrokeNum ? 1 : 0\n    }))\n  }, {\n    force: true\n  })];\n};\nconst startUserStroke = (id, point) => {\n  return [new Mutation('quiz.activeUserStrokeId', id, {\n    force: true\n  }), new Mutation(`userStrokes.${id}`, {\n    points: [point],\n    opacity: 1\n  }, {\n    force: true\n  })];\n};\nconst updateUserStroke = (userStrokeId, points) => {\n  return [new Mutation(`userStrokes.${userStrokeId}.points`, points, {\n    force: true\n  })];\n};\nconst hideUserStroke = (userStrokeId, duration) => {\n  return [new Mutation(`userStrokes.${userStrokeId}.opacity`, 0, {\n    duration\n  })];\n};\nconst removeAllUserStrokes = userStrokeIds => {\n  return (userStrokeIds === null || userStrokeIds === void 0 ? void 0 : userStrokeIds.map(userStrokeId => new Mutation(`userStrokes.${userStrokeId}`, null, {\n    force: true\n  }))) || [];\n};\nconst highlightCompleteChar = (character, color, duration) => {\n  return [new Mutation('options.highlightColor', color), ...hideCharacter('highlight', character), ...showCharacter('highlight', character, duration / 2), ...hideCharacter('highlight', character, duration / 2)];\n};\n\nconst getDrawnPath = userStroke => ({\n  pathString: getPathString(userStroke.externalPoints),\n  points: userStroke.points.map(point => round(point))\n});\n\nclass Quiz {\n  constructor(character, renderState, positioner) {\n    this._currentStrokeIndex = 0;\n    this._mistakesOnStroke = 0;\n    this._totalMistakes = 0;\n    this._character = character;\n    this._renderState = renderState;\n    this._isActive = false;\n    this._positioner = positioner;\n  }\n\n  startQuiz(options) {\n    if (this._userStrokesIds) {\n      this._renderState.run(removeAllUserStrokes(this._userStrokesIds));\n    }\n\n    this._userStrokesIds = [];\n    this._isActive = true;\n    this._options = options;\n    const startIndex = fixIndex(options.quizStartStrokeNum, this._character.strokes.length);\n    this._currentStrokeIndex = Math.min(startIndex, this._character.strokes.length - 1);\n    this._mistakesOnStroke = 0;\n    this._totalMistakes = 0;\n    return this._renderState.run(startQuiz(this._character, options.strokeFadeDuration, this._currentStrokeIndex));\n  }\n\n  startUserStroke(externalPoint) {\n    var _this$_userStrokesIds;\n\n    if (!this._isActive) {\n      return null;\n    }\n\n    if (this._userStroke) {\n      return this.endUserStroke();\n    }\n\n    const point = this._positioner.convertExternalPoint(externalPoint);\n\n    const strokeId = counter();\n    this._userStroke = new UserStroke(strokeId, point, externalPoint);\n    (_this$_userStrokesIds = this._userStrokesIds) === null || _this$_userStrokesIds === void 0 ? void 0 : _this$_userStrokesIds.push(strokeId);\n    return this._renderState.run(startUserStroke(strokeId, point));\n  }\n\n  continueUserStroke(externalPoint) {\n    if (!this._userStroke) {\n      return Promise.resolve();\n    }\n\n    const point = this._positioner.convertExternalPoint(externalPoint);\n\n    this._userStroke.appendPoint(point, externalPoint);\n\n    const nextPoints = this._userStroke.points.slice(0);\n\n    return this._renderState.run(updateUserStroke(this._userStroke.id, nextPoints));\n  }\n\n  setPositioner(positioner) {\n    this._positioner = positioner;\n  }\n\n  endUserStroke() {\n    var _this$_options$drawin;\n\n    if (!this._userStroke) return;\n\n    this._renderState.run(hideUserStroke(this._userStroke.id, (_this$_options$drawin = this._options.drawingFadeDuration) !== null && _this$_options$drawin !== void 0 ? _this$_options$drawin : 300)); // skip single-point strokes\n\n\n    if (this._userStroke.points.length === 1) {\n      this._userStroke = undefined;\n      return;\n    }\n\n    const {\n      acceptBackwardsStrokes,\n      markStrokeCorrectAfterMisses\n    } = this._options;\n\n    const currentStroke = this._getCurrentStroke();\n\n    const {\n      isMatch,\n      meta\n    } = strokeMatches(this._userStroke, this._character, this._currentStrokeIndex, {\n      isOutlineVisible: this._renderState.state.character.outline.opacity > 0,\n      leniency: this._options.leniency,\n      averageDistanceThreshold: this._options.averageDistanceThreshold\n    }); // if markStrokeCorrectAfterMisses is passed, just force the stroke to count as correct after n tries\n\n    const isForceAccepted = markStrokeCorrectAfterMisses && this._mistakesOnStroke + 1 >= markStrokeCorrectAfterMisses;\n    const isAccepted = isMatch || isForceAccepted || meta.isStrokeBackwards && acceptBackwardsStrokes;\n\n    if (isAccepted) {\n      this._handleSuccess(meta);\n    } else {\n      this._handleFailure(meta);\n\n      const {\n        showHintAfterMisses,\n        highlightColor,\n        strokeHighlightSpeed\n      } = this._options;\n\n      if (showHintAfterMisses !== false && this._mistakesOnStroke >= showHintAfterMisses) {\n        this._renderState.run(highlightStroke(currentStroke, colorStringToVals(highlightColor), strokeHighlightSpeed));\n      }\n    }\n\n    this._userStroke = undefined;\n  }\n\n  cancel() {\n    this._isActive = false;\n\n    if (this._userStrokesIds) {\n      this._renderState.run(removeAllUserStrokes(this._userStrokesIds));\n    }\n  }\n\n  _getStrokeData({\n    isCorrect,\n    meta\n  }) {\n    return {\n      character: this._character.symbol,\n      strokeNum: this._currentStrokeIndex,\n      mistakesOnStroke: this._mistakesOnStroke,\n      totalMistakes: this._totalMistakes,\n      strokesRemaining: this._character.strokes.length - this._currentStrokeIndex - (isCorrect ? 1 : 0),\n      drawnPath: getDrawnPath(this._userStroke),\n      isBackwards: meta.isStrokeBackwards\n    };\n  }\n\n  nextStroke() {\n    if (!this._options) return;\n    const {\n      strokes,\n      symbol\n    } = this._character;\n    const {\n      onComplete,\n      highlightOnComplete,\n      strokeFadeDuration,\n      highlightCompleteColor,\n      highlightColor,\n      strokeHighlightDuration\n    } = this._options;\n    let animation = showStroke('main', this._currentStrokeIndex, strokeFadeDuration);\n    this._mistakesOnStroke = 0;\n    this._currentStrokeIndex += 1;\n    const isComplete = this._currentStrokeIndex === strokes.length;\n\n    if (isComplete) {\n      this._isActive = false;\n      onComplete === null || onComplete === void 0 ? void 0 : onComplete({\n        character: symbol,\n        totalMistakes: this._totalMistakes\n      });\n\n      if (highlightOnComplete) {\n        animation = animation.concat(highlightCompleteChar(this._character, colorStringToVals(highlightCompleteColor || highlightColor), (strokeHighlightDuration || 0) * 2));\n      }\n    }\n\n    this._renderState.run(animation);\n  }\n\n  _handleSuccess(meta) {\n    if (!this._options) return;\n    const {\n      onCorrectStroke\n    } = this._options;\n    onCorrectStroke === null || onCorrectStroke === void 0 ? void 0 : onCorrectStroke({ ...this._getStrokeData({\n        isCorrect: true,\n        meta\n      })\n    });\n    this.nextStroke();\n  }\n\n  _handleFailure(meta) {\n    var _this$_options$onMist, _this$_options;\n\n    this._mistakesOnStroke += 1;\n    this._totalMistakes += 1;\n    (_this$_options$onMist = (_this$_options = this._options).onMistake) === null || _this$_options$onMist === void 0 ? void 0 : _this$_options$onMist.call(_this$_options, this._getStrokeData({\n      isCorrect: false,\n      meta\n    }));\n  }\n\n  _getCurrentStroke() {\n    return this._character.strokes[this._currentStrokeIndex];\n  }\n\n}\n\nfunction createElm(elmType) {\n  return document.createElementNS('http://www.w3.org/2000/svg', elmType);\n}\nfunction attr(elm, name, value) {\n  elm.setAttributeNS(null, name, value);\n}\nfunction attrs(elm, attrsMap) {\n  Object.keys(attrsMap).forEach(attrName => attr(elm, attrName, attrsMap[attrName]));\n} // inspired by https://talk.observablehq.com/t/hanzi-writer-renders-incorrectly-inside-an-observable-notebook-on-a-mobile-browser/1898\n\nfunction urlIdRef(id) {\n  let prefix = '';\n\n  if (window.location && window.location.href) {\n    prefix = window.location.href.replace(/#[^#]*$/, '').replace(/\"/gi, '%22');\n  }\n\n  return `url(\"${prefix}#${id}\")`;\n}\nfunction removeElm(elm) {\n  var _elm$parentNode;\n\n  elm === null || elm === void 0 ? void 0 : (_elm$parentNode = elm.parentNode) === null || _elm$parentNode === void 0 ? void 0 : _elm$parentNode.removeChild(elm);\n}\n\nclass StrokeRendererBase {\n  constructor(stroke) {\n    this.stroke = stroke;\n    this._pathLength = stroke.getLength() + StrokeRendererBase.STROKE_WIDTH / 2;\n  }\n\n  _getStrokeDashoffset(displayPortion) {\n    return this._pathLength * 0.999 * (1 - displayPortion);\n  }\n\n  _getColor({\n    strokeColor,\n    radicalColor\n  }) {\n    return radicalColor && this.stroke.isInRadical ? radicalColor : strokeColor;\n  }\n\n}\nStrokeRendererBase.STROKE_WIDTH = 200;\n\nconst STROKE_WIDTH = 200;\n/** This is a stroke composed of several stroke parts **/\n\nclass StrokeRenderer extends StrokeRendererBase {\n  constructor(stroke) {\n    super(stroke);\n    this._oldProps = undefined;\n  }\n\n  mount(target) {\n    this._animationPath = createElm('path');\n    this._clip = createElm('clipPath');\n    this._strokePath = createElm('path');\n    const maskId = `mask-${counter()}`;\n    attr(this._clip, 'id', maskId);\n    attr(this._strokePath, 'd', this.stroke.path);\n    this._animationPath.style.opacity = '0';\n    attr(this._animationPath, 'clip-path', urlIdRef(maskId));\n    const extendedMaskPoints = extendStart(this.stroke.points, STROKE_WIDTH / 2);\n    attr(this._animationPath, 'd', getPathString(extendedMaskPoints));\n    attrs(this._animationPath, {\n      stroke: '#FFFFFF',\n      'stroke-width': STROKE_WIDTH.toString(),\n      fill: 'none',\n      'stroke-linecap': 'round',\n      'stroke-linejoin': 'miter',\n      'stroke-dasharray': `${this._pathLength},${this._pathLength}`\n    });\n\n    this._clip.appendChild(this._strokePath);\n\n    target.defs.appendChild(this._clip);\n    target.svg.appendChild(this._animationPath);\n    return this;\n  }\n\n  render(props) {\n    var _this$_oldProps, _this$_oldProps2;\n\n    if (props === this._oldProps || !this._animationPath) {\n      return;\n    }\n\n    if (props.displayPortion !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.displayPortion)) {\n      this._animationPath.style.strokeDashoffset = this._getStrokeDashoffset(props.displayPortion).toString();\n    }\n\n    const color = this._getColor(props);\n\n    if (!this._oldProps || color !== this._getColor(this._oldProps)) {\n      const {\n        r,\n        g,\n        b,\n        a\n      } = color;\n      attrs(this._animationPath, {\n        stroke: `rgba(${r},${g},${b},${a})`\n      });\n    }\n\n    if (props.opacity !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity)) {\n      this._animationPath.style.opacity = props.opacity.toString();\n    }\n\n    this._oldProps = props;\n  }\n\n}\n\nclass CharacterRenderer {\n  constructor(character) {\n    this._oldProps = undefined;\n    this._strokeRenderers = character.strokes.map(stroke => new StrokeRenderer(stroke));\n  }\n\n  mount(target) {\n    const subTarget = target.createSubRenderTarget();\n    this._group = subTarget.svg;\n\n    this._strokeRenderers.forEach(strokeRenderer => {\n      strokeRenderer.mount(subTarget);\n    });\n  }\n\n  render(props) {\n    var _this$_oldProps, _this$_oldProps3;\n\n    if (props === this._oldProps || !this._group) {\n      return;\n    }\n\n    const {\n      opacity,\n      strokes,\n      strokeColor,\n      radicalColor = null\n    } = props;\n\n    if (opacity !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.opacity)) {\n      this._group.style.opacity = opacity.toString(); // MS browsers seem to have a bug where if SVG is set to display:none, it sometimes breaks.\n      // More info: https://github.com/chanind/hanzi-writer/issues/164\n      // this is just a perf improvement, so disable for MS browsers\n\n      if (!isMsBrowser) {\n        var _this$_oldProps2;\n\n        if (opacity === 0) {\n          this._group.style.display = 'none';\n        } else if (((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity) === 0) {\n          this._group.style.removeProperty('display');\n        }\n      }\n    }\n\n    const colorsChanged = !this._oldProps || strokeColor !== this._oldProps.strokeColor || radicalColor !== this._oldProps.radicalColor;\n\n    if (colorsChanged || strokes !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.strokes)) {\n      for (let i = 0; i < this._strokeRenderers.length; i++) {\n        var _this$_oldProps4;\n\n        if (!colorsChanged && (_this$_oldProps4 = this._oldProps) !== null && _this$_oldProps4 !== void 0 && _this$_oldProps4.strokes && strokes[i] === this._oldProps.strokes[i]) {\n          continue;\n        }\n\n        this._strokeRenderers[i].render({\n          strokeColor,\n          radicalColor,\n          opacity: strokes[i].opacity,\n          displayPortion: strokes[i].displayPortion\n        });\n      }\n    }\n\n    this._oldProps = props;\n  }\n\n}\n\nclass UserStrokeRenderer {\n  constructor() {\n    this._oldProps = undefined;\n  }\n\n  mount(target) {\n    this._path = createElm('path');\n    target.svg.appendChild(this._path);\n  }\n\n  render(props) {\n    var _this$_oldProps, _this$_oldProps2, _this$_oldProps3, _this$_oldProps4;\n\n    if (!this._path || props === this._oldProps) {\n      return;\n    }\n\n    if (props.strokeColor !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.strokeColor) || props.strokeWidth !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.strokeWidth)) {\n      const {\n        r,\n        g,\n        b,\n        a\n      } = props.strokeColor;\n      attrs(this._path, {\n        fill: 'none',\n        stroke: `rgba(${r},${g},${b},${a})`,\n        'stroke-width': props.strokeWidth.toString(),\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round'\n      });\n    }\n\n    if (props.opacity !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.opacity)) {\n      attr(this._path, 'opacity', props.opacity.toString());\n    }\n\n    if (props.points !== ((_this$_oldProps4 = this._oldProps) === null || _this$_oldProps4 === void 0 ? void 0 : _this$_oldProps4.points)) {\n      attr(this._path, 'd', getPathString(props.points));\n    }\n\n    this._oldProps = props;\n  }\n\n  destroy() {\n    removeElm(this._path);\n  }\n\n}\n\nclass HanziWriterRenderer {\n  constructor(character, positioner) {\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer(character);\n    this._outlineCharRenderer = new CharacterRenderer(character);\n    this._highlightCharRenderer = new CharacterRenderer(character);\n    this._userStrokeRenderers = {};\n  }\n\n  mount(target) {\n    const positionedTarget = target.createSubRenderTarget();\n    const group = positionedTarget.svg;\n    const {\n      xOffset,\n      yOffset,\n      height,\n      scale\n    } = this._positioner;\n    attr(group, 'transform', `translate(${xOffset}, ${height - yOffset}) scale(${scale}, ${-1 * scale})`);\n\n    this._outlineCharRenderer.mount(positionedTarget);\n\n    this._mainCharRenderer.mount(positionedTarget);\n\n    this._highlightCharRenderer.mount(positionedTarget);\n\n    this._positionedTarget = positionedTarget;\n  }\n\n  render(props) {\n    const {\n      main,\n      outline,\n      highlight\n    } = props.character;\n    const {\n      outlineColor,\n      radicalColor,\n      highlightColor,\n      strokeColor,\n      drawingWidth,\n      drawingColor\n    } = props.options;\n\n    this._outlineCharRenderer.render({\n      opacity: outline.opacity,\n      strokes: outline.strokes,\n      strokeColor: outlineColor\n    });\n\n    this._mainCharRenderer.render({\n      opacity: main.opacity,\n      strokes: main.strokes,\n      strokeColor,\n      radicalColor: radicalColor\n    });\n\n    this._highlightCharRenderer.render({\n      opacity: highlight.opacity,\n      strokes: highlight.strokes,\n      strokeColor: highlightColor\n    });\n\n    const userStrokes = props.userStrokes || {};\n\n    for (const userStrokeId in this._userStrokeRenderers) {\n      if (!userStrokes[userStrokeId]) {\n        var _this$_userStrokeRend;\n\n        (_this$_userStrokeRend = this._userStrokeRenderers[userStrokeId]) === null || _this$_userStrokeRend === void 0 ? void 0 : _this$_userStrokeRend.destroy();\n        delete this._userStrokeRenderers[userStrokeId];\n      }\n    }\n\n    for (const userStrokeId in userStrokes) {\n      const stroke = userStrokes[userStrokeId];\n\n      if (!stroke) {\n        continue;\n      }\n\n      const userStrokeProps = {\n        strokeWidth: drawingWidth,\n        strokeColor: drawingColor,\n        ...stroke\n      };\n\n      const strokeRenderer = (() => {\n        if (this._userStrokeRenderers[userStrokeId]) {\n          return this._userStrokeRenderers[userStrokeId];\n        }\n\n        const newStrokeRenderer = new UserStrokeRenderer();\n        newStrokeRenderer.mount(this._positionedTarget);\n        this._userStrokeRenderers[userStrokeId] = newStrokeRenderer;\n        return newStrokeRenderer;\n      })();\n\n      strokeRenderer.render(userStrokeProps);\n    }\n  }\n\n  destroy() {\n    removeElm(this._positionedTarget.svg);\n    this._positionedTarget.defs.innerHTML = '';\n  }\n\n}\n\n/** Generic render target */\nclass RenderTargetBase {\n  constructor(node) {\n    this.node = node;\n  }\n\n  addPointerStartListener(callback) {\n    this.node.addEventListener('mousedown', evt => {\n      callback(this._eventify(evt, this._getMousePoint));\n    });\n    this.node.addEventListener('touchstart', evt => {\n      callback(this._eventify(evt, this._getTouchPoint));\n    });\n  }\n\n  addPointerMoveListener(callback) {\n    this.node.addEventListener('mousemove', evt => {\n      callback(this._eventify(evt, this._getMousePoint));\n    });\n    this.node.addEventListener('touchmove', evt => {\n      callback(this._eventify(evt, this._getTouchPoint));\n    });\n  }\n\n  addPointerEndListener(callback) {\n    // TODO: find a way to not need global listeners\n    document.addEventListener('mouseup', callback);\n    document.addEventListener('touchend', callback);\n  }\n\n  getBoundingClientRect() {\n    return this.node.getBoundingClientRect();\n  }\n\n  updateDimensions(width, height) {\n    this.node.setAttribute('width', `${width}`);\n    this.node.setAttribute('height', `${height}`);\n  }\n\n  _eventify(evt, pointFunc) {\n    return {\n      getPoint: () => pointFunc.call(this, evt),\n      preventDefault: () => evt.preventDefault()\n    };\n  }\n\n  _getMousePoint(evt) {\n    const {\n      left,\n      top\n    } = this.getBoundingClientRect();\n    const x = evt.clientX - left;\n    const y = evt.clientY - top;\n    return {\n      x,\n      y\n    };\n  }\n\n  _getTouchPoint(evt) {\n    const {\n      left,\n      top\n    } = this.getBoundingClientRect();\n    const x = evt.touches[0].clientX - left;\n    const y = evt.touches[0].clientY - top;\n    return {\n      x,\n      y\n    };\n  }\n\n}\n\nclass RenderTarget extends RenderTargetBase {\n  constructor(svg, defs) {\n    super(svg);\n    this.svg = svg;\n    this.defs = defs;\n\n    if ('createSVGPoint' in svg) {\n      this._pt = svg.createSVGPoint();\n    }\n  }\n\n  static init(elmOrId, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\n    }\n\n    const nodeType = element.nodeName.toUpperCase();\n\n    const svg = (() => {\n      if (nodeType === 'SVG' || nodeType === 'G') {\n        return element;\n      } else {\n        const svg = createElm('svg');\n        element.appendChild(svg);\n        return svg;\n      }\n    })();\n\n    attrs(svg, {\n      width,\n      height\n    });\n    const defs = createElm('defs');\n    svg.appendChild(defs);\n    return new RenderTarget(svg, defs);\n  }\n\n  createSubRenderTarget() {\n    const group = createElm('g');\n    this.svg.appendChild(group);\n    return new RenderTarget(group, this.defs);\n  }\n\n  _getMousePoint(evt) {\n    if (this._pt) {\n      this._pt.x = evt.clientX;\n      this._pt.y = evt.clientY;\n\n      if ('getScreenCTM' in this.node) {\n        var _this$node$getScreenC;\n\n        const localPt = this._pt.matrixTransform((_this$node$getScreenC = this.node.getScreenCTM()) === null || _this$node$getScreenC === void 0 ? void 0 : _this$node$getScreenC.inverse());\n\n        return {\n          x: localPt.x,\n          y: localPt.y\n        };\n      }\n    }\n\n    return super._getMousePoint.call(this, evt);\n  }\n\n  _getTouchPoint(evt) {\n    if (this._pt) {\n      this._pt.x = evt.touches[0].clientX;\n      this._pt.y = evt.touches[0].clientY;\n\n      if ('getScreenCTM' in this.node) {\n        var _this$node$getScreenC2;\n\n        const localPt = this._pt.matrixTransform((_this$node$getScreenC2 = this.node.getScreenCTM()) === null || _this$node$getScreenC2 === void 0 ? void 0 : _this$node$getScreenC2.inverse());\n\n        return {\n          x: localPt.x,\n          y: localPt.y\n        };\n      }\n    }\n\n    return super._getTouchPoint(evt);\n  }\n\n}\n\nvar svgRenderer = {\n  HanziWriterRenderer,\n  createRenderTarget: RenderTarget.init\n};\n\nconst drawPath = (ctx, points) => {\n  ctx.beginPath();\n  const start = points[0];\n  const remainingPoints = points.slice(1);\n  ctx.moveTo(start.x, start.y);\n\n  for (const point of remainingPoints) {\n    ctx.lineTo(point.x, point.y);\n  }\n\n  ctx.stroke();\n};\n/**\n * Break a path string into a series of canvas path commands\n *\n * Note: only works with the subset of SVG paths used by MakeMeAHanzi data\n * @param pathString\n */\n\nconst pathStringToCanvas = pathString => {\n  const pathParts = pathString.split(/(^|\\s+)(?=[A-Z])/).filter(part => part !== ' ');\n  const commands = [ctx => ctx.beginPath()];\n\n  for (const part of pathParts) {\n    const [cmd, ...rawParams] = part.split(/\\s+/);\n    const params = rawParams.map(param => parseFloat(param));\n\n    if (cmd === 'M') {\n      commands.push(ctx => ctx.moveTo(...params));\n    } else if (cmd === 'L') {\n      commands.push(ctx => ctx.lineTo(...params));\n    } else if (cmd === 'C') {\n      commands.push(ctx => ctx.bezierCurveTo(...params));\n    } else if (cmd === 'Q') {\n      commands.push(ctx => ctx.quadraticCurveTo(...params));\n    } else ;\n  }\n\n  return ctx => commands.forEach(cmd => cmd(ctx));\n};\n\n/** this is a stroke composed of several stroke parts */\n\nclass StrokeRenderer$1 extends StrokeRendererBase {\n  constructor(stroke, usePath2D = true) {\n    super(stroke);\n\n    if (usePath2D && Path2D) {\n      this._path2D = new Path2D(this.stroke.path);\n    } else {\n      this._pathCmd = pathStringToCanvas(this.stroke.path);\n    }\n\n    this._extendedMaskPoints = extendStart(this.stroke.points, StrokeRendererBase.STROKE_WIDTH / 2);\n  }\n\n  render(ctx, props) {\n    if (props.opacity < 0.05) {\n      return;\n    }\n\n    ctx.save();\n\n    if (this._path2D) {\n      ctx.clip(this._path2D);\n    } else {\n      var _this$_pathCmd;\n\n      (_this$_pathCmd = this._pathCmd) === null || _this$_pathCmd === void 0 ? void 0 : _this$_pathCmd.call(this, ctx); // wechat bugs out if the clip path isn't stroked or filled\n\n      ctx.globalAlpha = 0;\n      ctx.stroke();\n      ctx.clip();\n    }\n\n    const {\n      r,\n      g,\n      b,\n      a\n    } = this._getColor(props);\n\n    const color = a === 1 ? `rgb(${r},${g},${b})` : `rgb(${r},${g},${b},${a})`;\n\n    const dashOffset = this._getStrokeDashoffset(props.displayPortion);\n\n    ctx.globalAlpha = props.opacity;\n    ctx.strokeStyle = color;\n    ctx.fillStyle = color;\n    ctx.lineWidth = StrokeRendererBase.STROKE_WIDTH;\n    ctx.lineCap = 'round';\n    ctx.lineJoin = 'round'; // wechat sets dashOffset as a second param here. Should be harmless for browsers to add here too\n    // @ts-ignore\n\n    ctx.setLineDash([this._pathLength, this._pathLength], dashOffset);\n    ctx.lineDashOffset = dashOffset;\n    drawPath(ctx, this._extendedMaskPoints);\n    ctx.restore();\n  }\n\n}\n\nclass CharacterRenderer$1 {\n  constructor(character) {\n    this._strokeRenderers = character.strokes.map(stroke => new StrokeRenderer$1(stroke));\n  }\n\n  render(ctx, props) {\n    if (props.opacity < 0.05) return;\n    const {\n      opacity,\n      strokeColor,\n      radicalColor,\n      strokes\n    } = props;\n\n    for (let i = 0; i < this._strokeRenderers.length; i++) {\n      this._strokeRenderers[i].render(ctx, {\n        strokeColor,\n        radicalColor,\n        opacity: strokes[i].opacity * opacity,\n        displayPortion: strokes[i].displayPortion || 0\n      });\n    }\n  }\n\n}\n\nfunction renderUserStroke(ctx, props) {\n  if (props.opacity < 0.05) {\n    return;\n  }\n\n  const {\n    opacity,\n    strokeWidth,\n    strokeColor,\n    points\n  } = props;\n  const {\n    r,\n    g,\n    b,\n    a\n  } = strokeColor;\n  ctx.save();\n  ctx.globalAlpha = opacity;\n  ctx.lineWidth = strokeWidth;\n  ctx.strokeStyle = `rgba(${r},${g},${b},${a})`;\n  ctx.lineCap = 'round';\n  ctx.lineJoin = 'round';\n  drawPath(ctx, points);\n  ctx.restore();\n}\n\nclass HanziWriterRenderer$1 {\n  constructor(character, positioner) {\n    this.destroy = noop;\n    this._character = character;\n    this._positioner = positioner;\n    this._mainCharRenderer = new CharacterRenderer$1(character);\n    this._outlineCharRenderer = new CharacterRenderer$1(character);\n    this._highlightCharRenderer = new CharacterRenderer$1(character);\n  }\n\n  mount(target) {\n    this._target = target;\n  }\n\n  _animationFrame(cb) {\n    const {\n      width,\n      height,\n      scale,\n      xOffset,\n      yOffset\n    } = this._positioner;\n\n    const ctx = this._target.getContext();\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.save();\n    ctx.translate(xOffset, height - yOffset);\n    ctx.transform(1, 0, 0, -1, 0, 0);\n    ctx.scale(scale, scale);\n    cb(ctx);\n    ctx.restore(); // @ts-expect-error Verify if this is still needed for the \"wechat miniprogram\".\n\n    if (ctx.draw) {\n      // @ts-expect-error\n      ctx.draw();\n    }\n  }\n\n  render(props) {\n    const {\n      outline,\n      main,\n      highlight\n    } = props.character;\n    const {\n      outlineColor,\n      strokeColor,\n      radicalColor,\n      highlightColor,\n      drawingColor,\n      drawingWidth\n    } = props.options;\n\n    this._animationFrame(ctx => {\n      this._outlineCharRenderer.render(ctx, {\n        opacity: outline.opacity,\n        strokes: outline.strokes,\n        strokeColor: outlineColor\n      });\n\n      this._mainCharRenderer.render(ctx, {\n        opacity: main.opacity,\n        strokes: main.strokes,\n        strokeColor: strokeColor,\n        radicalColor: radicalColor\n      });\n\n      this._highlightCharRenderer.render(ctx, {\n        opacity: highlight.opacity,\n        strokes: highlight.strokes,\n        strokeColor: highlightColor\n      });\n\n      const userStrokes = props.userStrokes || {};\n\n      for (const userStrokeId in userStrokes) {\n        const userStroke = userStrokes[userStrokeId];\n\n        if (userStroke) {\n          const userStrokeProps = {\n            strokeWidth: drawingWidth,\n            strokeColor: drawingColor,\n            ...userStroke\n          };\n          renderUserStroke(ctx, userStrokeProps);\n        }\n      }\n    });\n  }\n\n}\n\nclass RenderTarget$1 extends RenderTargetBase {\n  constructor(canvas) {\n    super(canvas);\n  }\n\n  static init(elmOrId, width = '100%', height = '100%') {\n    const element = (() => {\n      if (typeof elmOrId === 'string') {\n        return document.getElementById(elmOrId);\n      }\n\n      return elmOrId;\n    })();\n\n    if (!element) {\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\n    }\n\n    const nodeType = element.nodeName.toUpperCase();\n\n    const canvas = (() => {\n      if (nodeType === 'CANVAS') {\n        return element;\n      }\n\n      const canvas = document.createElement('canvas');\n      element.appendChild(canvas);\n      return canvas;\n    })();\n\n    canvas.setAttribute('width', width);\n    canvas.setAttribute('height', height);\n    return new RenderTarget$1(canvas);\n  }\n\n  getContext() {\n    return this.node.getContext('2d');\n  }\n\n}\n\nvar canvasRenderer = {\n  HanziWriterRenderer: HanziWriterRenderer$1,\n  createRenderTarget: RenderTarget$1.init\n};\n\nconst VERSION = '2.0';\n\nconst getCharDataUrl = char => `https://cdn.jsdelivr.net/npm/hanzi-writer-data@${VERSION}/${char}.json`;\n\nconst defaultCharDataLoader = (char, onLoad, onError) => {\n  // load char data from hanziwriter cdn (currently hosted on jsdelivr)\n  const xhr = new XMLHttpRequest();\n\n  if (xhr.overrideMimeType) {\n    // IE 9 and 10 don't seem to support this...\n    xhr.overrideMimeType('application/json');\n  }\n\n  xhr.open('GET', getCharDataUrl(char), true);\n\n  xhr.onerror = event => {\n    onError(xhr, event);\n  };\n\n  xhr.onreadystatechange = () => {\n    // TODO: error handling\n    if (xhr.readyState !== 4) return;\n\n    if (xhr.status === 200) {\n      onLoad(JSON.parse(xhr.responseText));\n    } else if (xhr.status !== 0 && onError) {\n      onError(xhr);\n    }\n  };\n\n  xhr.send(null);\n};\n\nconst defaultOptions = {\n  charDataLoader: defaultCharDataLoader,\n  onLoadCharDataError: null,\n  onLoadCharDataSuccess: null,\n  showOutline: true,\n  showCharacter: true,\n  renderer: 'svg',\n  // positioning options\n  width: 0,\n  height: 0,\n  padding: 20,\n  // animation options\n  strokeAnimationSpeed: 1,\n  strokeFadeDuration: 400,\n  strokeHighlightDuration: 200,\n  strokeHighlightSpeed: 2,\n  delayBetweenStrokes: 1000,\n  delayBetweenLoops: 2000,\n  // colors\n  strokeColor: '#555',\n  radicalColor: null,\n  highlightColor: '#AAF',\n  outlineColor: '#DDD',\n  drawingColor: '#333',\n  // quiz options\n  leniency: 1,\n  showHintAfterMisses: 3,\n  highlightOnComplete: true,\n  highlightCompleteColor: null,\n  markStrokeCorrectAfterMisses: false,\n  acceptBackwardsStrokes: false,\n  quizStartStrokeNum: 0,\n  averageDistanceThreshold: 350,\n  // undocumented obscure options\n  drawingFadeDuration: 300,\n  drawingWidth: 4,\n  strokeWidth: 2,\n  outlineWidth: 2,\n  rendererOverride: {}\n};\n\nclass LoadingManager {\n  constructor(options) {\n    this._loadCounter = 0;\n    this._isLoading = false;\n    /** use this to attribute to determine if there was a problem with loading */\n\n    this.loadingFailed = false;\n    this._options = options;\n  }\n\n  _debouncedLoad(char, count) {\n    // these wrappers ignore all responses except the most recent.\n    const wrappedResolve = data => {\n      if (count === this._loadCounter) {\n        var _this$_resolve;\n\n        (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this, data);\n      }\n    };\n\n    const wrappedReject = reason => {\n      if (count === this._loadCounter) {\n        var _this$_reject;\n\n        (_this$_reject = this._reject) === null || _this$_reject === void 0 ? void 0 : _this$_reject.call(this, reason);\n      }\n    };\n\n    const returnedData = this._options.charDataLoader(char, wrappedResolve, wrappedReject);\n\n    if (returnedData) {\n      if ('then' in returnedData) {\n        returnedData.then(wrappedResolve).catch(wrappedReject);\n      } else {\n        wrappedResolve(returnedData);\n      }\n    }\n  }\n\n  _setupLoadingPromise() {\n    return new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    }).then(data => {\n      var _this$_options$onLoad, _this$_options;\n\n      this._isLoading = false;\n      (_this$_options$onLoad = (_this$_options = this._options).onLoadCharDataSuccess) === null || _this$_options$onLoad === void 0 ? void 0 : _this$_options$onLoad.call(_this$_options, data);\n      return data;\n    }).catch(reason => {\n      this._isLoading = false;\n      this.loadingFailed = true; // If the user has provided an \"onLoadCharDataError\", call this function\n      // Otherwise, throw the promise\n\n      if (this._options.onLoadCharDataError) {\n        this._options.onLoadCharDataError(reason);\n\n        return;\n      } // If error callback wasn't provided, throw an error so the developer will be aware something went wrong\n\n\n      if (reason instanceof Error) {\n        throw reason;\n      }\n\n      const err = new Error(`Failed to load char data for ${this._loadingChar}`);\n      err.reason = reason;\n      throw err;\n    });\n  }\n\n  loadCharData(char) {\n    this._loadingChar = char;\n\n    const promise = this._setupLoadingPromise();\n\n    this.loadingFailed = false;\n    this._isLoading = true;\n    this._loadCounter++;\n\n    this._debouncedLoad(char, this._loadCounter);\n\n    return promise;\n  }\n\n}\n\nclass HanziWriter {\n  constructor(element, options = {}) {\n    const {\n      HanziWriterRenderer,\n      createRenderTarget\n    } = options.renderer === 'canvas' ? canvasRenderer : svgRenderer;\n    const rendererOverride = options.rendererOverride || {};\n    this._renderer = {\n      HanziWriterRenderer: rendererOverride.HanziWriterRenderer || HanziWriterRenderer,\n      createRenderTarget: rendererOverride.createRenderTarget || createRenderTarget\n    }; // wechat miniprogram component needs direct access to the render target, so this is public\n\n    this.target = this._renderer.createRenderTarget(element, options.width, options.height);\n    this._options = this._assignOptions(options);\n    this._loadingManager = new LoadingManager(this._options);\n\n    this._setupListeners();\n  }\n  /** Main entry point */\n\n\n  static create(element, character, options) {\n    const writer = new HanziWriter(element, options);\n    writer.setCharacter(character);\n    return writer;\n  }\n\n  static loadCharacterData(character, options = {}) {\n    const loadingManager = (() => {\n      const {\n        _loadingManager,\n        _loadingOptions\n      } = HanziWriter;\n\n      if ((_loadingManager === null || _loadingManager === void 0 ? void 0 : _loadingManager._loadingChar) === character && _loadingOptions === options) {\n        return _loadingManager;\n      }\n\n      return new LoadingManager({ ...defaultOptions,\n        ...options\n      });\n    })();\n\n    HanziWriter._loadingManager = loadingManager;\n    HanziWriter._loadingOptions = options;\n    return loadingManager.loadCharData(character);\n  }\n\n  static getScalingTransform(width, height, padding = 0) {\n    const positioner = new Positioner({\n      width,\n      height,\n      padding\n    });\n    return {\n      x: positioner.xOffset,\n      y: positioner.yOffset,\n      scale: positioner.scale,\n      transform: trim(`\n        translate(${positioner.xOffset}, ${positioner.height - positioner.yOffset})\n        scale(${positioner.scale}, ${-1 * positioner.scale})\n      `).replace(/\\s+/g, ' ')\n    };\n  }\n\n  showCharacter(options = {}) {\n    this._options.showCharacter = true;\n    return this._withData(() => {\n      var _this$_renderState;\n\n      return (_this$_renderState = this._renderState) === null || _this$_renderState === void 0 ? void 0 : _this$_renderState.run(showCharacter('main', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete;\n\n        (_options$onComplete = options.onComplete) === null || _options$onComplete === void 0 ? void 0 : _options$onComplete.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  hideCharacter(options = {}) {\n    this._options.showCharacter = false;\n    return this._withData(() => {\n      var _this$_renderState2;\n\n      return (_this$_renderState2 = this._renderState) === null || _this$_renderState2 === void 0 ? void 0 : _this$_renderState2.run(hideCharacter('main', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete2;\n\n        (_options$onComplete2 = options.onComplete) === null || _options$onComplete2 === void 0 ? void 0 : _options$onComplete2.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  animateCharacter(options = {}) {\n    this.cancelQuiz();\n    return this._withData(() => {\n      var _this$_renderState3;\n\n      return (_this$_renderState3 = this._renderState) === null || _this$_renderState3 === void 0 ? void 0 : _this$_renderState3.run(animateCharacter('main', this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes)).then(res => {\n        var _options$onComplete3;\n\n        (_options$onComplete3 = options.onComplete) === null || _options$onComplete3 === void 0 ? void 0 : _options$onComplete3.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  animateStroke(strokeNum, options = {}) {\n    this.cancelQuiz();\n    return this._withData(() => {\n      var _this$_renderState4;\n\n      return (_this$_renderState4 = this._renderState) === null || _this$_renderState4 === void 0 ? void 0 : _this$_renderState4.run(animateSingleStroke('main', this._character, fixIndex(strokeNum, this._character.strokes.length), this._options.strokeAnimationSpeed)).then(res => {\n        var _options$onComplete4;\n\n        (_options$onComplete4 = options.onComplete) === null || _options$onComplete4 === void 0 ? void 0 : _options$onComplete4.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  highlightStroke(strokeNum, options = {}) {\n    const promise = () => {\n      if (!this._character || !this._renderState) {\n        return;\n      }\n\n      return this._renderState.run(highlightStroke(selectIndex(this._character.strokes, strokeNum), colorStringToVals(this._options.highlightColor), this._options.strokeHighlightSpeed)).then(res => {\n        var _options$onComplete5;\n\n        (_options$onComplete5 = options.onComplete) === null || _options$onComplete5 === void 0 ? void 0 : _options$onComplete5.call(options, res);\n        return res;\n      });\n    };\n\n    return this._withData(promise);\n  }\n\n  async loopCharacterAnimation() {\n    this.cancelQuiz();\n    return this._withData(() => this._renderState.run(animateCharacterLoop('main', this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes, this._options.delayBetweenLoops), {\n      loop: true\n    }));\n  }\n\n  pauseAnimation() {\n    return this._withData(() => {\n      var _this$_renderState5;\n\n      return (_this$_renderState5 = this._renderState) === null || _this$_renderState5 === void 0 ? void 0 : _this$_renderState5.pauseAll();\n    });\n  }\n\n  resumeAnimation() {\n    return this._withData(() => {\n      var _this$_renderState6;\n\n      return (_this$_renderState6 = this._renderState) === null || _this$_renderState6 === void 0 ? void 0 : _this$_renderState6.resumeAll();\n    });\n  }\n\n  showOutline(options = {}) {\n    this._options.showOutline = true;\n    return this._withData(() => {\n      var _this$_renderState7;\n\n      return (_this$_renderState7 = this._renderState) === null || _this$_renderState7 === void 0 ? void 0 : _this$_renderState7.run(showCharacter('outline', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete6;\n\n        (_options$onComplete6 = options.onComplete) === null || _options$onComplete6 === void 0 ? void 0 : _options$onComplete6.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  hideOutline(options = {}) {\n    this._options.showOutline = false;\n    return this._withData(() => {\n      var _this$_renderState8;\n\n      return (_this$_renderState8 = this._renderState) === null || _this$_renderState8 === void 0 ? void 0 : _this$_renderState8.run(hideCharacter('outline', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\n        var _options$onComplete7;\n\n        (_options$onComplete7 = options.onComplete) === null || _options$onComplete7 === void 0 ? void 0 : _options$onComplete7.call(options, res);\n        return res;\n      });\n    });\n  }\n  /** Updates the size of the writer instance without resetting render state */\n\n\n  updateDimensions({\n    width,\n    height,\n    padding\n  }) {\n    if (width !== undefined) this._options.width = width;\n    if (height !== undefined) this._options.height = height;\n    if (padding !== undefined) this._options.padding = padding;\n    this.target.updateDimensions(this._options.width, this._options.height); // if there's already a character drawn, destroy and recreate the renderer in the same state\n\n    if (this._character && this._renderState && this._hanziWriterRenderer && this._positioner) {\n      this._hanziWriterRenderer.destroy();\n\n      const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(this._character); // TODO: this should probably implement EventEmitter instead of manually tracking updates like this\n\n\n      this._renderState.overwriteOnStateChange(nextState => hanziWriterRenderer.render(nextState));\n\n      hanziWriterRenderer.render(this._renderState.state); // update the current quiz as well, if one is active\n\n      if (this._quiz) {\n        this._quiz.setPositioner(this._positioner);\n      }\n    }\n  }\n\n  updateColor(colorName, colorVal, options = {}) {\n    var _options$duration;\n\n    let mutations = [];\n\n    const fixedColorVal = (() => {\n      // If we're removing radical color, tween it to the stroke color\n      if (colorName === 'radicalColor' && !colorVal) {\n        return this._options.strokeColor;\n      }\n\n      return colorVal;\n    })();\n\n    const mappedColor = colorStringToVals(fixedColorVal);\n    this._options[colorName] = colorVal;\n    const duration = (_options$duration = options.duration) !== null && _options$duration !== void 0 ? _options$duration : this._options.strokeFadeDuration;\n    mutations = mutations.concat(updateColor(colorName, mappedColor, duration)); // make sure to set radicalColor back to null after the transition finishes if val == null\n\n    if (colorName === 'radicalColor' && !colorVal) {\n      mutations = mutations.concat(updateColor(colorName, null, 0));\n    }\n\n    return this._withData(() => {\n      var _this$_renderState9;\n\n      return (_this$_renderState9 = this._renderState) === null || _this$_renderState9 === void 0 ? void 0 : _this$_renderState9.run(mutations).then(res => {\n        var _options$onComplete8;\n\n        (_options$onComplete8 = options.onComplete) === null || _options$onComplete8 === void 0 ? void 0 : _options$onComplete8.call(options, res);\n        return res;\n      });\n    });\n  }\n\n  quiz(quizOptions = {}) {\n    return this._withData(async () => {\n      if (this._character && this._renderState && this._positioner) {\n        this.cancelQuiz();\n        this._quiz = new Quiz(this._character, this._renderState, this._positioner);\n        this._options = { ...this._options,\n          ...quizOptions\n        };\n\n        this._quiz.startQuiz(this._options);\n      }\n    });\n  }\n\n  skipQuizStroke() {\n    if (this._quiz) {\n      this._quiz.nextStroke();\n    }\n  }\n\n  cancelQuiz() {\n    if (this._quiz) {\n      this._quiz.cancel();\n\n      this._quiz = undefined;\n    }\n  }\n\n  setCharacter(char) {\n    this.cancelQuiz();\n    this._char = char;\n\n    if (this._hanziWriterRenderer) {\n      this._hanziWriterRenderer.destroy();\n    }\n\n    if (this._renderState) {\n      this._renderState.cancelAll();\n    }\n\n    this._hanziWriterRenderer = null;\n    this._withDataPromise = this._loadingManager.loadCharData(char).then(pathStrings => {\n      // if \"pathStrings\" isn't set, \".catch()\"\" was probably called and loading likely failed\n      if (!pathStrings || this._loadingManager.loadingFailed) {\n        return;\n      }\n\n      this._character = parseCharData(char, pathStrings);\n      this._renderState = new RenderState(this._character, this._options, nextState => hanziWriterRenderer.render(nextState));\n\n      const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(this._character);\n\n      hanziWriterRenderer.render(this._renderState.state);\n    });\n    return this._withDataPromise;\n  }\n\n  _initAndMountHanziWriterRenderer(character) {\n    const {\n      width,\n      height,\n      padding\n    } = this._options;\n    this._positioner = new Positioner({\n      width,\n      height,\n      padding\n    });\n    const hanziWriterRenderer = new this._renderer.HanziWriterRenderer(character, this._positioner);\n    hanziWriterRenderer.mount(this.target);\n    this._hanziWriterRenderer = hanziWriterRenderer;\n    return hanziWriterRenderer;\n  }\n\n  async getCharacterData() {\n    if (!this._char) {\n      throw new Error('setCharacter() must be called before calling getCharacterData()');\n    }\n\n    const character = await this._withData(() => this._character);\n    return character;\n  }\n\n  _assignOptions(options) {\n    const mergedOptions = { ...defaultOptions,\n      ...options\n    }; // backfill strokeAnimationSpeed if deprecated strokeAnimationDuration is provided instead\n\n    if (options.strokeAnimationDuration && !options.strokeAnimationSpeed) {\n      mergedOptions.strokeAnimationSpeed = 500 / options.strokeAnimationDuration;\n    }\n\n    if (options.strokeHighlightDuration && !options.strokeHighlightSpeed) {\n      mergedOptions.strokeHighlightSpeed = 500 / mergedOptions.strokeHighlightDuration;\n    }\n\n    if (!options.highlightCompleteColor) {\n      mergedOptions.highlightCompleteColor = mergedOptions.highlightColor;\n    }\n\n    return this._fillWidthAndHeight(mergedOptions);\n  }\n  /** returns a new options object with width and height filled in if missing */\n\n\n  _fillWidthAndHeight(options) {\n    const filledOpts = { ...options\n    };\n\n    if (filledOpts.width && !filledOpts.height) {\n      filledOpts.height = filledOpts.width;\n    } else if (filledOpts.height && !filledOpts.width) {\n      filledOpts.width = filledOpts.height;\n    } else if (!filledOpts.width && !filledOpts.height) {\n      const {\n        width,\n        height\n      } = this.target.getBoundingClientRect();\n      const minDim = Math.min(width, height);\n      filledOpts.width = minDim;\n      filledOpts.height = minDim;\n    }\n\n    return filledOpts;\n  }\n\n  _withData(func) {\n    // if this._loadingManager.loadingFailed, then loading failed before this method was called\n    if (this._loadingManager.loadingFailed) {\n      throw Error('Failed to load character data. Call setCharacter and try again.');\n    }\n\n    if (this._withDataPromise) {\n      return this._withDataPromise.then(() => {\n        if (!this._loadingManager.loadingFailed) {\n          return func();\n        }\n      });\n    }\n\n    return Promise.resolve().then(func);\n  }\n\n  _setupListeners() {\n    this.target.addPointerStartListener(evt => {\n      if (this._quiz) {\n        evt.preventDefault();\n\n        this._quiz.startUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerMoveListener(evt => {\n      if (this._quiz) {\n        evt.preventDefault();\n\n        this._quiz.continueUserStroke(evt.getPoint());\n      }\n    });\n    this.target.addPointerEndListener(() => {\n      var _this$_quiz;\n\n      (_this$_quiz = this._quiz) === null || _this$_quiz === void 0 ? void 0 : _this$_quiz.endUserStroke();\n    });\n  }\n\n}\n/** Singleton instance of LoadingManager. Only set in `loadCharacterData` */\n\nHanziWriter._loadingManager = null;\n/** Singleton loading options. Only set in `loadCharacterData` */\n\nHanziWriter._loadingOptions = null;\n\nmodule.exports = HanziWriter;\n//# sourceMappingURL=index.cjs.js.map\n"]}