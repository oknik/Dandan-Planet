{"version":3,"sources":["index.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * Hanzi Writer v3.7.2 | https://chanind.github.io/hanzi-writer\r\n */\r\n\r\n\r\n\r\nvar _globalObj$requestAni, _globalObj$cancelAnim, _globalObj$navigator; // hacky way to get around rollup not properly setting `global` to `window` in browser\r\n\r\n\r\nconst globalObj = typeof window === 'undefined' ? global : window;\r\nconst performanceNow = globalObj.performance && (() => globalObj.performance.now()) || (() => Date.now());\r\nconst requestAnimationFrame = ((_globalObj$requestAni = globalObj.requestAnimationFrame) === null || _globalObj$requestAni === void 0 ? void 0 : _globalObj$requestAni.bind(globalObj)) || (callback => setTimeout(() => callback(performanceNow()), 1000 / 60));\r\nconst cancelAnimationFrame = ((_globalObj$cancelAnim = globalObj.cancelAnimationFrame) === null || _globalObj$cancelAnim === void 0 ? void 0 : _globalObj$cancelAnim.bind(globalObj)) || clearTimeout; // Object.assign polyfill, because IE :/\r\nfunction arrLast(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\nconst fixIndex = (index, length) => {\r\n  // helper to handle negative indexes in array indices\r\n  if (index < 0) {\r\n    return length + index;\r\n  }\r\n\r\n  return index;\r\n};\r\nconst selectIndex = (arr, index) => {\r\n  // helper to select item from array at index, supporting negative indexes\r\n  return arr[fixIndex(index, arr.length)];\r\n};\r\nfunction copyAndMergeDeep(base, override) {\r\n  const output = { ...base\r\n  };\r\n\r\n  for (const key in override) {\r\n    const baseVal = base[key];\r\n    const overrideVal = override[key];\r\n\r\n    if (baseVal === overrideVal) {\r\n      continue;\r\n    }\r\n\r\n    if (baseVal && overrideVal && typeof baseVal === 'object' && typeof overrideVal === 'object' && !Array.isArray(overrideVal)) {\r\n      output[key] = copyAndMergeDeep(baseVal, overrideVal);\r\n    } else {\r\n      // @ts-ignore\r\n      output[key] = overrideVal;\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n/** basically a simplified version of lodash.get, selects a key out of an object like 'a.b' from {a: {b: 7}} */\r\n\r\nfunction inflate(scope, obj) {\r\n  const parts = scope.split('.');\r\n  const final = {};\r\n  let current = final;\r\n\r\n  for (let i = 0; i < parts.length; i++) {\r\n    const cap = i === parts.length - 1 ? obj : {};\r\n    current[parts[i]] = cap;\r\n    current = cap;\r\n  }\r\n\r\n  return final;\r\n}\r\nlet count = 0;\r\nfunction counter() {\r\n  count++;\r\n  return count;\r\n}\r\nfunction average(arr) {\r\n  const sum = arr.reduce((acc, val) => val + acc, 0);\r\n  return sum / arr.length;\r\n}\r\nfunction colorStringToVals(colorString) {\r\n  const normalizedColor = colorString.toUpperCase().trim(); // based on https://stackoverflow.com/a/21648508\r\n\r\n  if (/^#([A-F0-9]{3}){1,2}$/.test(normalizedColor)) {\r\n    let hexParts = normalizedColor.substring(1).split('');\r\n\r\n    if (hexParts.length === 3) {\r\n      hexParts = [hexParts[0], hexParts[0], hexParts[1], hexParts[1], hexParts[2], hexParts[2]];\r\n    }\r\n\r\n    const hexStr = `${hexParts.join('')}`;\r\n    return {\r\n      r: parseInt(hexStr.slice(0, 2), 16),\r\n      g: parseInt(hexStr.slice(2, 4), 16),\r\n      b: parseInt(hexStr.slice(4, 6), 16),\r\n      a: 1\r\n    };\r\n  }\r\n\r\n  const rgbMatch = normalizedColor.match(/^RGBA?\\((\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)(?:\\s*,\\s*(\\d*\\.?\\d+))?\\)$/);\r\n\r\n  if (rgbMatch) {\r\n    return {\r\n      r: parseInt(rgbMatch[1], 10),\r\n      g: parseInt(rgbMatch[2], 10),\r\n      b: parseInt(rgbMatch[3], 10),\r\n      // @ts-expect-error ts-migrate(2554) FIXME: Expected 1 arguments, but got 2.\r\n      a: parseFloat(rgbMatch[4] || 1, 10)\r\n    };\r\n  }\r\n\r\n  throw new Error(`Invalid color: ${colorString}`);\r\n}\r\nconst trim = string => string.replace(/^\\s+/, '').replace(/\\s+$/, ''); // return a new array-like object with int keys where each key is item\r\n// ex: objRepeat({x: 8}, 3) === {0: {x: 8}, 1: {x: 8}, 2: {x: 8}}\r\n\r\nfunction objRepeat(item, times) {\r\n  const obj = {};\r\n\r\n  for (let i = 0; i < times; i++) {\r\n    obj[i] = item;\r\n  }\r\n\r\n  return obj;\r\n} // similar to objRepeat, but takes in a callback which is called for each index in the object\r\n\r\nfunction objRepeatCb(times, cb) {\r\n  const obj = {};\r\n\r\n  for (let i = 0; i < times; i++) {\r\n    obj[i] = cb(i);\r\n  }\r\n\r\n  return obj;\r\n}\r\nconst ua = ((_globalObj$navigator = globalObj.navigator) === null || _globalObj$navigator === void 0 ? void 0 : _globalObj$navigator.userAgent) || '';\r\nconst isMsBrowser = ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0; // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n\r\nconst noop = () => {};\r\n\r\nclass RenderState {\r\n  constructor(character, options, onStateChange = noop) {\r\n    this._mutationChains = [];\r\n    this._onStateChange = onStateChange;\r\n    this.state = {\r\n      options: {\r\n        drawingFadeDuration: options.drawingFadeDuration,\r\n        drawingWidth: options.drawingWidth,\r\n        drawingColor: colorStringToVals(options.drawingColor),\r\n        strokeColor: colorStringToVals(options.strokeColor),\r\n        outlineColor: colorStringToVals(options.outlineColor),\r\n        radicalColor: colorStringToVals(options.radicalColor || options.strokeColor),\r\n        highlightColor: colorStringToVals(options.highlightColor)\r\n      },\r\n      character: {\r\n        main: {\r\n          opacity: options.showCharacter ? 1 : 0,\r\n          strokes: {}\r\n        },\r\n        outline: {\r\n          opacity: options.showOutline ? 1 : 0,\r\n          strokes: {}\r\n        },\r\n        highlight: {\r\n          opacity: 1,\r\n          strokes: {}\r\n        }\r\n      },\r\n      userStrokes: null\r\n    };\r\n\r\n    for (let i = 0; i < character.strokes.length; i++) {\r\n      this.state.character.main.strokes[i] = {\r\n        opacity: 1,\r\n        displayPortion: 1\r\n      };\r\n      this.state.character.outline.strokes[i] = {\r\n        opacity: 1,\r\n        displayPortion: 1\r\n      };\r\n      this.state.character.highlight.strokes[i] = {\r\n        opacity: 0,\r\n        displayPortion: 1\r\n      };\r\n    }\r\n  }\r\n\r\n  overwriteOnStateChange(onStateChange) {\r\n    this._onStateChange = onStateChange;\r\n  }\r\n\r\n  updateState(stateChanges) {\r\n    const nextState = copyAndMergeDeep(this.state, stateChanges);\r\n\r\n    this._onStateChange(nextState, this.state);\r\n\r\n    this.state = nextState;\r\n  }\r\n\r\n  run(mutations, options = {}) {\r\n    const scopes = mutations.map(mut => mut.scope);\r\n    this.cancelMutations(scopes);\r\n    return new Promise(resolve => {\r\n      const mutationChain = {\r\n        _isActive: true,\r\n        _index: 0,\r\n        _resolve: resolve,\r\n        _mutations: mutations,\r\n        _loop: options.loop,\r\n        _scopes: scopes\r\n      };\r\n\r\n      this._mutationChains.push(mutationChain);\r\n\r\n      this._run(mutationChain);\r\n    });\r\n  }\r\n\r\n  _run(mutationChain) {\r\n    if (!mutationChain._isActive) {\r\n      return;\r\n    }\r\n\r\n    const mutations = mutationChain._mutations;\r\n\r\n    if (mutationChain._index >= mutations.length) {\r\n      if (mutationChain._loop) {\r\n        mutationChain._index = 0; // eslint-disable-line no-param-reassign\r\n      } else {\r\n        mutationChain._isActive = false; // eslint-disable-line no-param-reassign\r\n\r\n        this._mutationChains = this._mutationChains.filter(chain => chain !== mutationChain); // The chain is done - resolve the promise to signal it finished successfully\r\n\r\n        mutationChain._resolve({\r\n          canceled: false\r\n        });\r\n\r\n        return;\r\n      }\r\n    }\r\n\r\n    const activeMutation = mutationChain._mutations[mutationChain._index];\r\n    activeMutation.run(this).then(() => {\r\n      if (mutationChain._isActive) {\r\n        mutationChain._index++; // eslint-disable-line no-param-reassign\r\n\r\n        this._run(mutationChain);\r\n      }\r\n    });\r\n  }\r\n\r\n  _getActiveMutations() {\r\n    return this._mutationChains.map(chain => chain._mutations[chain._index]);\r\n  }\r\n\r\n  pauseAll() {\r\n    this._getActiveMutations().forEach(mutation => mutation.pause());\r\n  }\r\n\r\n  resumeAll() {\r\n    this._getActiveMutations().forEach(mutation => mutation.resume());\r\n  }\r\n\r\n  cancelMutations(scopesToCancel) {\r\n    for (const chain of this._mutationChains) {\r\n      for (const chainId of chain._scopes) {\r\n        for (const scopeToCancel of scopesToCancel) {\r\n          if (chainId.startsWith(scopeToCancel) || scopeToCancel.startsWith(chainId)) {\r\n            this._cancelMutationChain(chain);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  cancelAll() {\r\n    this.cancelMutations(['']);\r\n  }\r\n\r\n  _cancelMutationChain(mutationChain) {\r\n    var _mutationChain$_resol;\r\n\r\n    mutationChain._isActive = false;\r\n\r\n    for (let i = mutationChain._index; i < mutationChain._mutations.length; i++) {\r\n      mutationChain._mutations[i].cancel(this);\r\n    }\r\n\r\n    (_mutationChain$_resol = mutationChain._resolve) === null || _mutationChain$_resol === void 0 ? void 0 : _mutationChain$_resol.call(mutationChain, {\r\n      canceled: true\r\n    });\r\n    this._mutationChains = this._mutationChains.filter(chain => chain !== mutationChain);\r\n  }\r\n\r\n}\r\n\r\nconst subtract = (p1, p2) => ({\r\n  x: p1.x - p2.x,\r\n  y: p1.y - p2.y\r\n});\r\nconst magnitude = point => Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));\r\nconst distance = (point1, point2) => magnitude(subtract(point1, point2));\r\nconst equals = (point1, point2) => point1.x === point2.x && point1.y === point2.y;\r\nconst round = (point, precision = 1) => {\r\n  const multiplier = precision * 10;\r\n  return {\r\n    x: Math.round(multiplier * point.x) / multiplier,\r\n    y: Math.round(multiplier * point.y) / multiplier\r\n  };\r\n};\r\nconst length = points => {\r\n  let lastPoint = points[0];\r\n  const pointsSansFirst = points.slice(1);\r\n  return pointsSansFirst.reduce((acc, point) => {\r\n    const dist = distance(point, lastPoint);\r\n    lastPoint = point;\r\n    return acc + dist;\r\n  }, 0);\r\n};\r\nconst cosineSimilarity = (point1, point2) => {\r\n  const rawDotProduct = point1.x * point2.x + point1.y * point2.y;\r\n  return rawDotProduct / magnitude(point1) / magnitude(point2);\r\n};\r\n/**\r\n * return a new point, p3, which is on the same line as p1 and p2, but distance away\r\n * from p2. p1, p2, p3 will always lie on the line in that order\r\n */\r\n\r\nconst _extendPointOnLine = (p1, p2, dist) => {\r\n  const vect = subtract(p2, p1);\r\n  const norm = dist / magnitude(vect);\r\n  return {\r\n    x: p2.x + norm * vect.x,\r\n    y: p2.y + norm * vect.y\r\n  };\r\n};\r\n/** based on http://www.kr.tuwien.ac.at/staff/eiter/et-archive/cdtr9464.pdf */\r\n\r\nconst frechetDist = (curve1, curve2) => {\r\n  const longCurve = curve1.length >= curve2.length ? curve1 : curve2;\r\n  const shortCurve = curve1.length >= curve2.length ? curve2 : curve1;\r\n\r\n  const calcVal = (i, j, prevResultsCol, curResultsCol) => {\r\n    if (i === 0 && j === 0) {\r\n      return distance(longCurve[0], shortCurve[0]);\r\n    }\r\n\r\n    if (i > 0 && j === 0) {\r\n      return Math.max(prevResultsCol[0], distance(longCurve[i], shortCurve[0]));\r\n    }\r\n\r\n    const lastResult = curResultsCol[curResultsCol.length - 1];\r\n\r\n    if (i === 0 && j > 0) {\r\n      return Math.max(lastResult, distance(longCurve[0], shortCurve[j]));\r\n    }\r\n\r\n    return Math.max(Math.min(prevResultsCol[j], prevResultsCol[j - 1], lastResult), distance(longCurve[i], shortCurve[j]));\r\n  };\r\n\r\n  let prevResultsCol = [];\r\n\r\n  for (let i = 0; i < longCurve.length; i++) {\r\n    const curResultsCol = [];\r\n\r\n    for (let j = 0; j < shortCurve.length; j++) {\r\n      // we only need the results from i - 1 and j - 1 to continue the calculation\r\n      // so we only need to hold onto the last column of calculated results\r\n      // prevResultsCol is results[i-1][:] in the original algorithm\r\n      // curResultsCol is results[i][:j-1] in the original algorithm\r\n      curResultsCol.push(calcVal(i, j, prevResultsCol, curResultsCol));\r\n    }\r\n\r\n    prevResultsCol = curResultsCol;\r\n  }\r\n\r\n  return prevResultsCol[shortCurve.length - 1];\r\n};\r\n/** break up long segments in the curve into smaller segments of len maxLen or smaller */\r\n\r\nconst subdivideCurve = (curve, maxLen = 0.05) => {\r\n  const newCurve = curve.slice(0, 1);\r\n\r\n  for (const point of curve.slice(1)) {\r\n    const prevPoint = newCurve[newCurve.length - 1];\r\n    const segLen = distance(point, prevPoint);\r\n\r\n    if (segLen > maxLen) {\r\n      const numNewPoints = Math.ceil(segLen / maxLen);\r\n      const newSegLen = segLen / numNewPoints;\r\n\r\n      for (let i = 0; i < numNewPoints; i++) {\r\n        newCurve.push(_extendPointOnLine(point, prevPoint, -1 * newSegLen * (i + 1)));\r\n      }\r\n    } else {\r\n      newCurve.push(point);\r\n    }\r\n  }\r\n\r\n  return newCurve;\r\n};\r\n/** redraw the curve using numPoints equally spaced out along the length of the curve */\r\n\r\nconst outlineCurve = (curve, numPoints = 30) => {\r\n  const curveLen = length(curve);\r\n  const segmentLen = curveLen / (numPoints - 1);\r\n  const outlinePoints = [curve[0]];\r\n  const endPoint = arrLast(curve);\r\n  const remainingCurvePoints = curve.slice(1);\r\n\r\n  for (let i = 0; i < numPoints - 2; i++) {\r\n    let lastPoint = arrLast(outlinePoints);\r\n    let remainingDist = segmentLen;\r\n    let outlinePointFound = false;\r\n\r\n    while (!outlinePointFound) {\r\n      const nextPointDist = distance(lastPoint, remainingCurvePoints[0]);\r\n\r\n      if (nextPointDist < remainingDist) {\r\n        remainingDist -= nextPointDist;\r\n        lastPoint = remainingCurvePoints.shift();\r\n      } else {\r\n        const nextPoint = _extendPointOnLine(lastPoint, remainingCurvePoints[0], remainingDist - nextPointDist);\r\n\r\n        outlinePoints.push(nextPoint);\r\n        outlinePointFound = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  outlinePoints.push(endPoint);\r\n  return outlinePoints;\r\n};\r\n/** translate and scale from https://en.wikipedia.org/wiki/Procrustes_analysis */\r\n\r\nconst normalizeCurve = curve => {\r\n  const outlinedCurve = outlineCurve(curve);\r\n  const meanX = average(outlinedCurve.map(point => point.x));\r\n  const meanY = average(outlinedCurve.map(point => point.y));\r\n  const mean = {\r\n    x: meanX,\r\n    y: meanY\r\n  };\r\n  const translatedCurve = outlinedCurve.map(point => subtract(point, mean));\r\n  const scale = Math.sqrt(average([Math.pow(translatedCurve[0].x, 2) + Math.pow(translatedCurve[0].y, 2), Math.pow(arrLast(translatedCurve).x, 2) + Math.pow(arrLast(translatedCurve).y, 2)]));\r\n  const scaledCurve = translatedCurve.map(point => ({\r\n    x: point.x / scale,\r\n    y: point.y / scale\r\n  }));\r\n  return subdivideCurve(scaledCurve);\r\n}; // rotate around the origin\r\n\r\nconst rotate = (curve, theta) => {\r\n  return curve.map(point => ({\r\n    x: Math.cos(theta) * point.x - Math.sin(theta) * point.y,\r\n    y: Math.sin(theta) * point.x + Math.cos(theta) * point.y\r\n  }));\r\n}; // remove intermediate points that are on the same line as the points to either side\r\n\r\nconst _filterParallelPoints = points => {\r\n  if (points.length < 3) return points;\r\n  const filteredPoints = [points[0], points[1]];\r\n  points.slice(2).forEach(point => {\r\n    const numFilteredPoints = filteredPoints.length;\r\n    const curVect = subtract(point, filteredPoints[numFilteredPoints - 1]);\r\n    const prevVect = subtract(filteredPoints[numFilteredPoints - 1], filteredPoints[numFilteredPoints - 2]); // this is the z coord of the cross-product. If this is 0 then they're parallel\r\n\r\n    const isParallel = curVect.y * prevVect.x - curVect.x * prevVect.y === 0;\r\n\r\n    if (isParallel) {\r\n      filteredPoints.pop();\r\n    }\r\n\r\n    filteredPoints.push(point);\r\n  });\r\n  return filteredPoints;\r\n};\r\nfunction getPathString(points, close = false) {\r\n  const start = round(points[0]);\r\n  const remainingPoints = points.slice(1);\r\n  let pathString = `M ${start.x} ${start.y}`;\r\n  remainingPoints.forEach(point => {\r\n    const roundedPoint = round(point);\r\n    pathString += ` L ${roundedPoint.x} ${roundedPoint.y}`;\r\n  });\r\n\r\n  if (close) {\r\n    pathString += 'Z';\r\n  }\r\n\r\n  return pathString;\r\n}\r\n/** take points on a path and move their start point backwards by distance */\r\n\r\nconst extendStart = (points, dist) => {\r\n  const filteredPoints = _filterParallelPoints(points);\r\n\r\n  if (filteredPoints.length < 2) return filteredPoints;\r\n  const p1 = filteredPoints[1];\r\n  const p2 = filteredPoints[0];\r\n\r\n  const newStart = _extendPointOnLine(p1, p2, dist);\r\n\r\n  const extendedPoints = filteredPoints.slice(1);\r\n  extendedPoints.unshift(newStart);\r\n  return extendedPoints;\r\n};\r\n\r\nclass Stroke {\r\n  constructor(path, points, strokeNum, isInRadical = false) {\r\n    this.path = path;\r\n    this.points = points;\r\n    this.strokeNum = strokeNum;\r\n    this.isInRadical = isInRadical;\r\n  }\r\n\r\n  getStartingPoint() {\r\n    return this.points[0];\r\n  }\r\n\r\n  getEndingPoint() {\r\n    return this.points[this.points.length - 1];\r\n  }\r\n\r\n  getLength() {\r\n    return length(this.points);\r\n  }\r\n\r\n  getVectors() {\r\n    let lastPoint = this.points[0];\r\n    const pointsSansFirst = this.points.slice(1);\r\n    return pointsSansFirst.map(point => {\r\n      const vector = subtract(point, lastPoint);\r\n      lastPoint = point;\r\n      return vector;\r\n    });\r\n  }\r\n\r\n  getDistance(point) {\r\n    const distances = this.points.map(strokePoint => distance(strokePoint, point));\r\n    return Math.min(...distances);\r\n  }\r\n\r\n  getAverageDistance(points) {\r\n    const totalDist = points.reduce((acc, point) => acc + this.getDistance(point), 0);\r\n    return totalDist / points.length;\r\n  }\r\n\r\n}\r\n\r\nclass Character {\r\n  constructor(symbol, strokes) {\r\n    this.symbol = symbol;\r\n    this.strokes = strokes;\r\n  }\r\n\r\n}\r\n\r\nfunction generateStrokes({\r\n  radStrokes,\r\n  strokes,\r\n  medians\r\n}) {\r\n  const isInRadical = strokeNum => {\r\n    var _radStrokes$indexOf;\r\n\r\n    return ((_radStrokes$indexOf = radStrokes === null || radStrokes === void 0 ? void 0 : radStrokes.indexOf(strokeNum)) !== null && _radStrokes$indexOf !== void 0 ? _radStrokes$indexOf : -1) >= 0;\r\n  };\r\n\r\n  return strokes.map((path, index) => {\r\n    const points = medians[index].map(pointData => {\r\n      const [x, y] = pointData;\r\n      return {\r\n        x,\r\n        y\r\n      };\r\n    });\r\n    return new Stroke(path, points, index, isInRadical(index));\r\n  });\r\n}\r\n\r\nfunction parseCharData(symbol, charJson) {\r\n  const strokes = generateStrokes(charJson);\r\n  return new Character(symbol, strokes);\r\n}\r\n\r\n// All makemeahanzi characters have the same bounding box\r\nconst CHARACTER_BOUNDS = [{\r\n  x: 0,\r\n  y: -124\r\n}, {\r\n  x: 1024,\r\n  y: 900\r\n}];\r\nconst [from, to] = CHARACTER_BOUNDS;\r\nconst preScaledWidth = to.x - from.x;\r\nconst preScaledHeight = to.y - from.y;\r\nclass Positioner {\r\n  constructor(options) {\r\n    const {\r\n      padding,\r\n      width,\r\n      height\r\n    } = options;\r\n    this.padding = padding;\r\n    this.width = width;\r\n    this.height = height;\r\n    const effectiveWidth = width - 2 * padding;\r\n    const effectiveHeight = height - 2 * padding;\r\n    const scaleX = effectiveWidth / preScaledWidth;\r\n    const scaleY = effectiveHeight / preScaledHeight;\r\n    this.scale = Math.min(scaleX, scaleY);\r\n    const xCenteringBuffer = padding + (effectiveWidth - this.scale * preScaledWidth) / 2;\r\n    const yCenteringBuffer = padding + (effectiveHeight - this.scale * preScaledHeight) / 2;\r\n    this.xOffset = -1 * from.x * this.scale + xCenteringBuffer;\r\n    this.yOffset = -1 * from.y * this.scale + yCenteringBuffer;\r\n  }\r\n\r\n  convertExternalPoint(point) {\r\n    const x = (point.x - this.xOffset) / this.scale;\r\n    const y = (this.height - this.yOffset - point.y) / this.scale;\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n\r\n}\r\n\r\nconst COSINE_SIMILARITY_THRESHOLD = 0; // -1 to 1, smaller = more lenient\r\n\r\nconst START_AND_END_DIST_THRESHOLD = 250; // bigger = more lenient\r\n\r\nconst FRECHET_THRESHOLD = 0.4; // bigger = more lenient\r\n\r\nconst MIN_LEN_THRESHOLD = 0.35; // smaller = more lenient\r\n\r\nfunction strokeMatches(userStroke, character, strokeNum, options = {}) {\r\n  const strokes = character.strokes;\r\n  const points = stripDuplicates(userStroke.points);\r\n\r\n  if (points.length < 2) {\r\n    return {\r\n      isMatch: false,\r\n      meta: {\r\n        isStrokeBackwards: false\r\n      }\r\n    };\r\n  }\r\n\r\n  const {\r\n    isMatch,\r\n    meta,\r\n    avgDist\r\n  } = getMatchData(points, strokes[strokeNum], options);\r\n\r\n  if (!isMatch) {\r\n    return {\r\n      isMatch,\r\n      meta\r\n    };\r\n  } // if there is a better match among strokes the user hasn't drawn yet, the user probably drew the wrong stroke\r\n\r\n\r\n  const laterStrokes = strokes.slice(strokeNum + 1);\r\n  let closestMatchDist = avgDist;\r\n\r\n  for (let i = 0; i < laterStrokes.length; i++) {\r\n    const {\r\n      isMatch,\r\n      avgDist\r\n    } = getMatchData(points, laterStrokes[i], { ...options,\r\n      checkBackwards: false\r\n    });\r\n\r\n    if (isMatch && avgDist < closestMatchDist) {\r\n      closestMatchDist = avgDist;\r\n    }\r\n  } // if there's a better match, rather that returning false automatically, try reducing leniency instead\r\n  // if leniency is already really high we can allow some similar strokes to pass\r\n\r\n\r\n  if (closestMatchDist < avgDist) {\r\n    // adjust leniency between 0.3 and 0.6 depending on how much of a better match the new match is\r\n    const leniencyAdjustment = 0.6 * (closestMatchDist + avgDist) / (2 * avgDist);\r\n    const {\r\n      isMatch,\r\n      meta\r\n    } = getMatchData(points, strokes[strokeNum], { ...options,\r\n      leniency: (options.leniency || 1) * leniencyAdjustment\r\n    });\r\n    return {\r\n      isMatch,\r\n      meta\r\n    };\r\n  }\r\n\r\n  return {\r\n    isMatch,\r\n    meta\r\n  };\r\n}\r\n\r\nconst startAndEndMatches = (points, closestStroke, leniency) => {\r\n  const startingDist = distance(closestStroke.getStartingPoint(), points[0]);\r\n  const endingDist = distance(closestStroke.getEndingPoint(), points[points.length - 1]);\r\n  return startingDist <= START_AND_END_DIST_THRESHOLD * leniency && endingDist <= START_AND_END_DIST_THRESHOLD * leniency;\r\n}; // returns a list of the direction of all segments in the line connecting the points\r\n\r\n\r\nconst getEdgeVectors = points => {\r\n  const vectors = [];\r\n  let lastPoint = points[0];\r\n  points.slice(1).forEach(point => {\r\n    vectors.push(subtract(point, lastPoint));\r\n    lastPoint = point;\r\n  });\r\n  return vectors;\r\n};\r\n\r\nconst directionMatches = (points, stroke) => {\r\n  const edgeVectors = getEdgeVectors(points);\r\n  const strokeVectors = stroke.getVectors();\r\n  const similarities = edgeVectors.map(edgeVector => {\r\n    const strokeSimilarities = strokeVectors.map(strokeVector => cosineSimilarity(strokeVector, edgeVector));\r\n    return Math.max(...strokeSimilarities);\r\n  });\r\n  const avgSimilarity = average(similarities);\r\n  return avgSimilarity > COSINE_SIMILARITY_THRESHOLD;\r\n};\r\n\r\nconst lengthMatches = (points, stroke, leniency) => {\r\n  return leniency * (length(points) + 25) / (stroke.getLength() + 25) >= MIN_LEN_THRESHOLD;\r\n};\r\n\r\nconst stripDuplicates = points => {\r\n  if (points.length < 2) return points;\r\n  const [firstPoint, ...rest] = points;\r\n  const dedupedPoints = [firstPoint];\r\n\r\n  for (const point of rest) {\r\n    if (!equals(point, dedupedPoints[dedupedPoints.length - 1])) {\r\n      dedupedPoints.push(point);\r\n    }\r\n  }\r\n\r\n  return dedupedPoints;\r\n};\r\n\r\nconst SHAPE_FIT_ROTATIONS = [Math.PI / 16, Math.PI / 32, 0, -1 * Math.PI / 32, -1 * Math.PI / 16];\r\n\r\nconst shapeFit = (curve1, curve2, leniency) => {\r\n  const normCurve1 = normalizeCurve(curve1);\r\n  const normCurve2 = normalizeCurve(curve2);\r\n  let minDist = Infinity;\r\n  SHAPE_FIT_ROTATIONS.forEach(theta => {\r\n    const dist = frechetDist(normCurve1, rotate(normCurve2, theta));\r\n\r\n    if (dist < minDist) {\r\n      minDist = dist;\r\n    }\r\n  });\r\n  return minDist <= FRECHET_THRESHOLD * leniency;\r\n};\r\n\r\nconst getMatchData = (points, stroke, options) => {\r\n  const {\r\n    leniency = 1,\r\n    isOutlineVisible = false,\r\n    checkBackwards = true,\r\n    averageDistanceThreshold = 350\r\n  } = options;\r\n  const avgDist = stroke.getAverageDistance(points);\r\n  const distMod = isOutlineVisible || stroke.strokeNum > 0 ? 0.5 : 1;\r\n  const withinDistThresh = avgDist <= averageDistanceThreshold * distMod * leniency; // short circuit for faster matching\r\n\r\n  if (!withinDistThresh) {\r\n    return {\r\n      isMatch: false,\r\n      avgDist,\r\n      meta: {\r\n        isStrokeBackwards: false\r\n      }\r\n    };\r\n  }\r\n\r\n  const startAndEndMatch = startAndEndMatches(points, stroke, leniency);\r\n  const directionMatch = directionMatches(points, stroke);\r\n  const shapeMatch = shapeFit(points, stroke.points, leniency);\r\n  const lengthMatch = lengthMatches(points, stroke, leniency);\r\n  const isMatch = withinDistThresh && startAndEndMatch && directionMatch && shapeMatch && lengthMatch;\r\n\r\n  if (checkBackwards && !isMatch) {\r\n    const backwardsMatchData = getMatchData([...points].reverse(), stroke, { ...options,\r\n      checkBackwards: false\r\n    });\r\n\r\n    if (backwardsMatchData.isMatch) {\r\n      return {\r\n        isMatch,\r\n        avgDist,\r\n        meta: {\r\n          isStrokeBackwards: true\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  return {\r\n    isMatch,\r\n    avgDist,\r\n    meta: {\r\n      isStrokeBackwards: false\r\n    }\r\n  };\r\n};\r\n\r\nclass UserStroke {\r\n  constructor(id, startingPoint, startingExternalPoint) {\r\n    this.id = id;\r\n    this.points = [startingPoint];\r\n    this.externalPoints = [startingExternalPoint];\r\n  }\r\n\r\n  appendPoint(point, externalPoint) {\r\n    this.points.push(point);\r\n    this.externalPoints.push(externalPoint);\r\n  }\r\n\r\n}\r\n\r\nclass Delay {\r\n  constructor(duration) {\r\n    this._duration = duration;\r\n    this._startTime = null;\r\n    this._paused = false;\r\n    this.scope = `delay.${duration}`;\r\n  }\r\n\r\n  run() {\r\n    this._startTime = performanceNow();\r\n    this._runningPromise = new Promise(resolve => {\r\n      this._resolve = resolve; // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\r\n\r\n      this._timeout = setTimeout(() => this.cancel(), this._duration);\r\n    });\r\n    return this._runningPromise;\r\n  }\r\n\r\n  pause() {\r\n    if (this._paused) return; // to pause, clear the timeout and rewrite this._duration with whatever time is remaining\r\n\r\n    const elapsedDelay = performance.now() - (this._startTime || 0);\r\n    this._duration = Math.max(0, this._duration - elapsedDelay);\r\n    clearTimeout(this._timeout);\r\n    this._paused = true;\r\n  }\r\n\r\n  resume() {\r\n    if (!this._paused) return;\r\n    this._startTime = performance.now(); // @ts-ignore return type of \"setTimeout\" in builds is parsed as `number` instead of `Timeout`\r\n\r\n    this._timeout = setTimeout(() => this.cancel(), this._duration);\r\n    this._paused = false;\r\n  }\r\n\r\n  cancel() {\r\n    clearTimeout(this._timeout);\r\n\r\n    if (this._resolve) {\r\n      this._resolve();\r\n    }\r\n\r\n    this._resolve = undefined;\r\n  }\r\n\r\n}\r\n\r\nclass Mutation {\r\n  /**\r\n   *\r\n   * @param scope a string representation of what fields this mutation affects from the state. This is used to cancel conflicting mutations\r\n   * @param valuesOrCallable a thunk containing the value to set, or a callback which will return those values\r\n   */\r\n  constructor(scope, valuesOrCallable, options = {}) {\r\n    this._tick = timing => {\r\n      if (this._startPauseTime !== null) {\r\n        return;\r\n      }\r\n\r\n      const progress = Math.min(1, (timing - this._startTime - this._pausedDuration) / this._duration);\r\n\r\n      if (progress === 1) {\r\n        this._renderState.updateState(this._values);\r\n\r\n        this._frameHandle = undefined;\r\n        this.cancel(this._renderState);\r\n      } else {\r\n        const easedProgress = ease(progress);\r\n        const stateChanges = getPartialValues(this._startState, this._values, easedProgress);\r\n\r\n        this._renderState.updateState(stateChanges);\r\n\r\n        this._frameHandle = requestAnimationFrame(this._tick);\r\n      }\r\n    };\r\n\r\n    this.scope = scope;\r\n    this._valuesOrCallable = valuesOrCallable;\r\n    this._duration = options.duration || 0;\r\n    this._force = options.force;\r\n    this._pausedDuration = 0;\r\n    this._startPauseTime = null;\r\n  }\r\n\r\n  run(renderState) {\r\n    if (!this._values) this._inflateValues(renderState);\r\n    if (this._duration === 0) renderState.updateState(this._values);\r\n\r\n    if (this._duration === 0 || isAlreadyAtEnd(renderState.state, this._values)) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    this._renderState = renderState;\r\n    this._startState = renderState.state;\r\n    this._startTime = performance.now();\r\n    this._frameHandle = requestAnimationFrame(this._tick);\r\n    return new Promise(resolve => {\r\n      this._resolve = resolve;\r\n    });\r\n  }\r\n\r\n  _inflateValues(renderState) {\r\n    let values = this._valuesOrCallable;\r\n\r\n    if (typeof this._valuesOrCallable === 'function') {\r\n      values = this._valuesOrCallable(renderState.state);\r\n    }\r\n\r\n    this._values = inflate(this.scope, values);\r\n  }\r\n\r\n  pause() {\r\n    if (this._startPauseTime !== null) {\r\n      return;\r\n    }\r\n\r\n    if (this._frameHandle) {\r\n      cancelAnimationFrame(this._frameHandle);\r\n    }\r\n\r\n    this._startPauseTime = performance.now();\r\n  }\r\n\r\n  resume() {\r\n    if (this._startPauseTime === null) {\r\n      return;\r\n    }\r\n\r\n    this._frameHandle = requestAnimationFrame(this._tick);\r\n    this._pausedDuration += performance.now() - this._startPauseTime;\r\n    this._startPauseTime = null;\r\n  }\r\n\r\n  cancel(renderState) {\r\n    var _this$_resolve;\r\n\r\n    (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this);\r\n    this._resolve = undefined;\r\n    cancelAnimationFrame(this._frameHandle || -1);\r\n    this._frameHandle = undefined;\r\n\r\n    if (this._force) {\r\n      if (!this._values) this._inflateValues(renderState);\r\n      renderState.updateState(this._values);\r\n    }\r\n  }\r\n\r\n}\r\nMutation.Delay = Delay;\r\n\r\nfunction getPartialValues(startValues, endValues, progress) {\r\n  const target = {};\r\n\r\n  for (const key in endValues) {\r\n    const endValue = endValues[key];\r\n    const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\r\n\r\n    if (typeof startValue === 'number' && typeof endValue === 'number' && endValue >= 0) {\r\n      target[key] = progress * (endValue - startValue) + startValue;\r\n    } else {\r\n      target[key] = getPartialValues(startValue, endValue, progress);\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction isAlreadyAtEnd(startValues, endValues) {\r\n  for (const key in endValues) {\r\n    const endValue = endValues[key];\r\n    const startValue = startValues === null || startValues === void 0 ? void 0 : startValues[key];\r\n\r\n    if (endValue >= 0) {\r\n      if (endValue !== startValue) {\r\n        return false;\r\n      }\r\n    } else if (!isAlreadyAtEnd(startValue, endValue)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n} // from https://github.com/maxwellito/vivus\r\n\r\n\r\nconst ease = x => -Math.cos(x * Math.PI) / 2 + 0.5;\r\n\r\nconst showStrokes = (charName, character, duration) => {\r\n  return [new Mutation(`character.${charName}.strokes`, objRepeat({\r\n    opacity: 1,\r\n    displayPortion: 1\r\n  }, character.strokes.length), {\r\n    duration,\r\n    force: true\r\n  })];\r\n};\r\nconst showCharacter = (charName, character, duration) => {\r\n  return [new Mutation(`character.${charName}`, {\r\n    opacity: 1,\r\n    strokes: objRepeat({\r\n      opacity: 1,\r\n      displayPortion: 1\r\n    }, character.strokes.length)\r\n  }, {\r\n    duration,\r\n    force: true\r\n  })];\r\n};\r\nconst hideCharacter = (charName, character, duration) => {\r\n  return [new Mutation(`character.${charName}.opacity`, 0, {\r\n    duration,\r\n    force: true\r\n  }), ...showStrokes(charName, character, 0)];\r\n};\r\nconst updateColor = (colorName, colorVal, duration) => {\r\n  return [new Mutation(`options.${colorName}`, colorVal, {\r\n    duration\r\n  })];\r\n};\r\nconst highlightStroke = (stroke, color, speed) => {\r\n  const strokeNum = stroke.strokeNum;\r\n  const duration = (stroke.getLength() + 600) / (3 * speed);\r\n  return [new Mutation('options.highlightColor', color), new Mutation('character.highlight', {\r\n    opacity: 1,\r\n    strokes: {\r\n      [strokeNum]: {\r\n        displayPortion: 0,\r\n        opacity: 0\r\n      }\r\n    }\r\n  }), new Mutation(`character.highlight.strokes.${strokeNum}`, {\r\n    displayPortion: 1,\r\n    opacity: 1\r\n  }, {\r\n    duration\r\n  }), new Mutation(`character.highlight.strokes.${strokeNum}.opacity`, 0, {\r\n    duration,\r\n    force: true\r\n  })];\r\n};\r\nconst animateStroke = (charName, stroke, speed) => {\r\n  const strokeNum = stroke.strokeNum;\r\n  const duration = (stroke.getLength() + 600) / (3 * speed);\r\n  return [new Mutation(`character.${charName}`, {\r\n    opacity: 1,\r\n    strokes: {\r\n      [strokeNum]: {\r\n        displayPortion: 0,\r\n        opacity: 1\r\n      }\r\n    }\r\n  }), new Mutation(`character.${charName}.strokes.${strokeNum}.displayPortion`, 1, {\r\n    duration\r\n  })];\r\n};\r\nconst animateSingleStroke = (charName, character, strokeNum, speed) => {\r\n  const mutationStateFunc = state => {\r\n    const curCharState = state.character[charName];\r\n    const mutationState = {\r\n      opacity: 1,\r\n      strokes: {}\r\n    };\r\n\r\n    for (let i = 0; i < character.strokes.length; i++) {\r\n      mutationState.strokes[i] = {\r\n        opacity: curCharState.opacity * curCharState.strokes[i].opacity\r\n      };\r\n    }\r\n\r\n    return mutationState;\r\n  };\r\n\r\n  const stroke = character.strokes[strokeNum];\r\n  return [new Mutation(`character.${charName}`, mutationStateFunc), ...animateStroke(charName, stroke, speed)];\r\n};\r\nconst showStroke = (charName, strokeNum, duration) => {\r\n  return [new Mutation(`character.${charName}.strokes.${strokeNum}`, {\r\n    displayPortion: 1,\r\n    opacity: 1\r\n  }, {\r\n    duration,\r\n    force: true\r\n  })];\r\n};\r\nconst animateCharacter = (charName, character, fadeDuration, speed, delayBetweenStrokes) => {\r\n  let mutations = hideCharacter(charName, character, fadeDuration);\r\n  mutations = mutations.concat(showStrokes(charName, character, 0));\r\n  mutations.push(new Mutation(`character.${charName}`, {\r\n    opacity: 1,\r\n    strokes: objRepeat({\r\n      opacity: 0\r\n    }, character.strokes.length)\r\n  }, {\r\n    force: true\r\n  }));\r\n  character.strokes.forEach((stroke, i) => {\r\n    if (i > 0) mutations.push(new Mutation.Delay(delayBetweenStrokes));\r\n    mutations = mutations.concat(animateStroke(charName, stroke, speed));\r\n  });\r\n  return mutations;\r\n};\r\nconst animateCharacterLoop = (charName, character, fadeDuration, speed, delayBetweenStrokes, delayBetweenLoops) => {\r\n  const mutations = animateCharacter(charName, character, fadeDuration, speed, delayBetweenStrokes);\r\n  mutations.push(new Mutation.Delay(delayBetweenLoops));\r\n  return mutations;\r\n};\r\n\r\nconst startQuiz = (character, fadeDuration, startStrokeNum) => {\r\n  return [...hideCharacter('main', character, fadeDuration), new Mutation('character.highlight', {\r\n    opacity: 1,\r\n    strokes: objRepeat({\r\n      opacity: 0\r\n    }, character.strokes.length)\r\n  }, {\r\n    force: true\r\n  }), new Mutation('character.main', {\r\n    opacity: 1,\r\n    strokes: objRepeatCb(character.strokes.length, i => ({\r\n      opacity: i < startStrokeNum ? 1 : 0\r\n    }))\r\n  }, {\r\n    force: true\r\n  })];\r\n};\r\nconst startUserStroke = (id, point) => {\r\n  return [new Mutation('quiz.activeUserStrokeId', id, {\r\n    force: true\r\n  }), new Mutation(`userStrokes.${id}`, {\r\n    points: [point],\r\n    opacity: 1\r\n  }, {\r\n    force: true\r\n  })];\r\n};\r\nconst updateUserStroke = (userStrokeId, points) => {\r\n  return [new Mutation(`userStrokes.${userStrokeId}.points`, points, {\r\n    force: true\r\n  })];\r\n};\r\nconst hideUserStroke = (userStrokeId, duration) => {\r\n  return [new Mutation(`userStrokes.${userStrokeId}.opacity`, 0, {\r\n    duration\r\n  })];\r\n};\r\nconst removeAllUserStrokes = userStrokeIds => {\r\n  return (userStrokeIds === null || userStrokeIds === void 0 ? void 0 : userStrokeIds.map(userStrokeId => new Mutation(`userStrokes.${userStrokeId}`, null, {\r\n    force: true\r\n  }))) || [];\r\n};\r\nconst highlightCompleteChar = (character, color, duration) => {\r\n  return [new Mutation('options.highlightColor', color), ...hideCharacter('highlight', character), ...showCharacter('highlight', character, duration / 2), ...hideCharacter('highlight', character, duration / 2)];\r\n};\r\n\r\nconst getDrawnPath = userStroke => ({\r\n  pathString: getPathString(userStroke.externalPoints),\r\n  points: userStroke.points.map(point => round(point))\r\n});\r\n\r\nclass Quiz {\r\n  constructor(character, renderState, positioner) {\r\n    this._currentStrokeIndex = 0;\r\n    this._mistakesOnStroke = 0;\r\n    this._totalMistakes = 0;\r\n    this._character = character;\r\n    this._renderState = renderState;\r\n    this._isActive = false;\r\n    this._positioner = positioner;\r\n  }\r\n\r\n  startQuiz(options) {\r\n    if (this._userStrokesIds) {\r\n      this._renderState.run(removeAllUserStrokes(this._userStrokesIds));\r\n    }\r\n\r\n    this._userStrokesIds = [];\r\n    this._isActive = true;\r\n    this._options = options;\r\n    const startIndex = fixIndex(options.quizStartStrokeNum, this._character.strokes.length);\r\n    this._currentStrokeIndex = Math.min(startIndex, this._character.strokes.length - 1);\r\n    this._mistakesOnStroke = 0;\r\n    this._totalMistakes = 0;\r\n    return this._renderState.run(startQuiz(this._character, options.strokeFadeDuration, this._currentStrokeIndex));\r\n  }\r\n\r\n  startUserStroke(externalPoint) {\r\n    var _this$_userStrokesIds;\r\n\r\n    if (!this._isActive) {\r\n      return null;\r\n    }\r\n\r\n    if (this._userStroke) {\r\n      return this.endUserStroke();\r\n    }\r\n\r\n    const point = this._positioner.convertExternalPoint(externalPoint);\r\n\r\n    const strokeId = counter();\r\n    this._userStroke = new UserStroke(strokeId, point, externalPoint);\r\n    (_this$_userStrokesIds = this._userStrokesIds) === null || _this$_userStrokesIds === void 0 ? void 0 : _this$_userStrokesIds.push(strokeId);\r\n    return this._renderState.run(startUserStroke(strokeId, point));\r\n  }\r\n\r\n  continueUserStroke(externalPoint) {\r\n    if (!this._userStroke) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const point = this._positioner.convertExternalPoint(externalPoint);\r\n\r\n    this._userStroke.appendPoint(point, externalPoint);\r\n\r\n    const nextPoints = this._userStroke.points.slice(0);\r\n\r\n    return this._renderState.run(updateUserStroke(this._userStroke.id, nextPoints));\r\n  }\r\n\r\n  setPositioner(positioner) {\r\n    this._positioner = positioner;\r\n  }\r\n\r\n  endUserStroke() {\r\n    var _this$_options$drawin;\r\n\r\n    if (!this._userStroke) return;\r\n\r\n    this._renderState.run(hideUserStroke(this._userStroke.id, (_this$_options$drawin = this._options.drawingFadeDuration) !== null && _this$_options$drawin !== void 0 ? _this$_options$drawin : 300)); // skip single-point strokes\r\n\r\n\r\n    if (this._userStroke.points.length === 1) {\r\n      this._userStroke = undefined;\r\n      return;\r\n    }\r\n\r\n    const {\r\n      acceptBackwardsStrokes,\r\n      markStrokeCorrectAfterMisses\r\n    } = this._options;\r\n\r\n    const currentStroke = this._getCurrentStroke();\r\n\r\n    const {\r\n      isMatch,\r\n      meta\r\n    } = strokeMatches(this._userStroke, this._character, this._currentStrokeIndex, {\r\n      isOutlineVisible: this._renderState.state.character.outline.opacity > 0,\r\n      leniency: this._options.leniency,\r\n      averageDistanceThreshold: this._options.averageDistanceThreshold\r\n    }); // if markStrokeCorrectAfterMisses is passed, just force the stroke to count as correct after n tries\r\n\r\n    const isForceAccepted = markStrokeCorrectAfterMisses && this._mistakesOnStroke + 1 >= markStrokeCorrectAfterMisses;\r\n    const isAccepted = isMatch || isForceAccepted || meta.isStrokeBackwards && acceptBackwardsStrokes;\r\n\r\n    if (isAccepted) {\r\n      this._handleSuccess(meta);\r\n    } else {\r\n      this._handleFailure(meta);\r\n\r\n      const {\r\n        showHintAfterMisses,\r\n        highlightColor,\r\n        strokeHighlightSpeed\r\n      } = this._options;\r\n\r\n      if (showHintAfterMisses !== false && this._mistakesOnStroke >= showHintAfterMisses) {\r\n        this._renderState.run(highlightStroke(currentStroke, colorStringToVals(highlightColor), strokeHighlightSpeed));\r\n      }\r\n    }\r\n\r\n    this._userStroke = undefined;\r\n  }\r\n\r\n  cancel() {\r\n    this._isActive = false;\r\n\r\n    if (this._userStrokesIds) {\r\n      this._renderState.run(removeAllUserStrokes(this._userStrokesIds));\r\n    }\r\n  }\r\n\r\n  _getStrokeData({\r\n    isCorrect,\r\n    meta\r\n  }) {\r\n    return {\r\n      character: this._character.symbol,\r\n      strokeNum: this._currentStrokeIndex,\r\n      mistakesOnStroke: this._mistakesOnStroke,\r\n      totalMistakes: this._totalMistakes,\r\n      strokesRemaining: this._character.strokes.length - this._currentStrokeIndex - (isCorrect ? 1 : 0),\r\n      drawnPath: getDrawnPath(this._userStroke),\r\n      isBackwards: meta.isStrokeBackwards\r\n    };\r\n  }\r\n\r\n  nextStroke() {\r\n    if (!this._options) return;\r\n    const {\r\n      strokes,\r\n      symbol\r\n    } = this._character;\r\n    const {\r\n      onComplete,\r\n      highlightOnComplete,\r\n      strokeFadeDuration,\r\n      highlightCompleteColor,\r\n      highlightColor,\r\n      strokeHighlightDuration\r\n    } = this._options;\r\n    let animation = showStroke('main', this._currentStrokeIndex, strokeFadeDuration);\r\n    this._mistakesOnStroke = 0;\r\n    this._currentStrokeIndex += 1;\r\n    const isComplete = this._currentStrokeIndex === strokes.length;\r\n\r\n    if (isComplete) {\r\n      this._isActive = false;\r\n      onComplete === null || onComplete === void 0 ? void 0 : onComplete({\r\n        character: symbol,\r\n        totalMistakes: this._totalMistakes\r\n      });\r\n\r\n      if (highlightOnComplete) {\r\n        animation = animation.concat(highlightCompleteChar(this._character, colorStringToVals(highlightCompleteColor || highlightColor), (strokeHighlightDuration || 0) * 2));\r\n      }\r\n    }\r\n\r\n    this._renderState.run(animation);\r\n  }\r\n\r\n  _handleSuccess(meta) {\r\n    if (!this._options) return;\r\n    const {\r\n      onCorrectStroke\r\n    } = this._options;\r\n    onCorrectStroke === null || onCorrectStroke === void 0 ? void 0 : onCorrectStroke({ ...this._getStrokeData({\r\n        isCorrect: true,\r\n        meta\r\n      })\r\n    });\r\n    this.nextStroke();\r\n  }\r\n\r\n  _handleFailure(meta) {\r\n    var _this$_options$onMist, _this$_options;\r\n\r\n    this._mistakesOnStroke += 1;\r\n    this._totalMistakes += 1;\r\n    (_this$_options$onMist = (_this$_options = this._options).onMistake) === null || _this$_options$onMist === void 0 ? void 0 : _this$_options$onMist.call(_this$_options, this._getStrokeData({\r\n      isCorrect: false,\r\n      meta\r\n    }));\r\n  }\r\n\r\n  _getCurrentStroke() {\r\n    return this._character.strokes[this._currentStrokeIndex];\r\n  }\r\n\r\n}\r\n\r\nfunction createElm(elmType) {\r\n  return document.createElementNS('http://www.w3.org/2000/svg', elmType);\r\n}\r\nfunction attr(elm, name, value) {\r\n  elm.setAttributeNS(null, name, value);\r\n}\r\nfunction attrs(elm, attrsMap) {\r\n  Object.keys(attrsMap).forEach(attrName => attr(elm, attrName, attrsMap[attrName]));\r\n} // inspired by https://talk.observablehq.com/t/hanzi-writer-renders-incorrectly-inside-an-observable-notebook-on-a-mobile-browser/1898\r\n\r\nfunction urlIdRef(id) {\r\n  let prefix = '';\r\n\r\n  if (window.location && window.location.href) {\r\n    prefix = window.location.href.replace(/#[^#]*$/, '').replace(/\"/gi, '%22');\r\n  }\r\n\r\n  return `url(\"${prefix}#${id}\")`;\r\n}\r\nfunction removeElm(elm) {\r\n  var _elm$parentNode;\r\n\r\n  elm === null || elm === void 0 ? void 0 : (_elm$parentNode = elm.parentNode) === null || _elm$parentNode === void 0 ? void 0 : _elm$parentNode.removeChild(elm);\r\n}\r\n\r\nclass StrokeRendererBase {\r\n  constructor(stroke) {\r\n    this.stroke = stroke;\r\n    this._pathLength = stroke.getLength() + StrokeRendererBase.STROKE_WIDTH / 2;\r\n  }\r\n\r\n  _getStrokeDashoffset(displayPortion) {\r\n    return this._pathLength * 0.999 * (1 - displayPortion);\r\n  }\r\n\r\n  _getColor({\r\n    strokeColor,\r\n    radicalColor\r\n  }) {\r\n    return radicalColor && this.stroke.isInRadical ? radicalColor : strokeColor;\r\n  }\r\n\r\n}\r\nStrokeRendererBase.STROKE_WIDTH = 200;\r\n\r\nconst STROKE_WIDTH = 200;\r\n/** This is a stroke composed of several stroke parts **/\r\n\r\nclass StrokeRenderer extends StrokeRendererBase {\r\n  constructor(stroke) {\r\n    super(stroke);\r\n    this._oldProps = undefined;\r\n  }\r\n\r\n  mount(target) {\r\n    this._animationPath = createElm('path');\r\n    this._clip = createElm('clipPath');\r\n    this._strokePath = createElm('path');\r\n    const maskId = `mask-${counter()}`;\r\n    attr(this._clip, 'id', maskId);\r\n    attr(this._strokePath, 'd', this.stroke.path);\r\n    this._animationPath.style.opacity = '0';\r\n    attr(this._animationPath, 'clip-path', urlIdRef(maskId));\r\n    const extendedMaskPoints = extendStart(this.stroke.points, STROKE_WIDTH / 2);\r\n    attr(this._animationPath, 'd', getPathString(extendedMaskPoints));\r\n    attrs(this._animationPath, {\r\n      stroke: '#FFFFFF',\r\n      'stroke-width': STROKE_WIDTH.toString(),\r\n      fill: 'none',\r\n      'stroke-linecap': 'round',\r\n      'stroke-linejoin': 'miter',\r\n      'stroke-dasharray': `${this._pathLength},${this._pathLength}`\r\n    });\r\n\r\n    this._clip.appendChild(this._strokePath);\r\n\r\n    target.defs.appendChild(this._clip);\r\n    target.svg.appendChild(this._animationPath);\r\n    return this;\r\n  }\r\n\r\n  render(props) {\r\n    var _this$_oldProps, _this$_oldProps2;\r\n\r\n    if (props === this._oldProps || !this._animationPath) {\r\n      return;\r\n    }\r\n\r\n    if (props.displayPortion !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.displayPortion)) {\r\n      this._animationPath.style.strokeDashoffset = this._getStrokeDashoffset(props.displayPortion).toString();\r\n    }\r\n\r\n    const color = this._getColor(props);\r\n\r\n    if (!this._oldProps || color !== this._getColor(this._oldProps)) {\r\n      const {\r\n        r,\r\n        g,\r\n        b,\r\n        a\r\n      } = color;\r\n      attrs(this._animationPath, {\r\n        stroke: `rgba(${r},${g},${b},${a})`\r\n      });\r\n    }\r\n\r\n    if (props.opacity !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity)) {\r\n      this._animationPath.style.opacity = props.opacity.toString();\r\n    }\r\n\r\n    this._oldProps = props;\r\n  }\r\n\r\n}\r\n\r\nclass CharacterRenderer {\r\n  constructor(character) {\r\n    this._oldProps = undefined;\r\n    this._strokeRenderers = character.strokes.map(stroke => new StrokeRenderer(stroke));\r\n  }\r\n\r\n  mount(target) {\r\n    const subTarget = target.createSubRenderTarget();\r\n    this._group = subTarget.svg;\r\n\r\n    this._strokeRenderers.forEach(strokeRenderer => {\r\n      strokeRenderer.mount(subTarget);\r\n    });\r\n  }\r\n\r\n  render(props) {\r\n    var _this$_oldProps, _this$_oldProps3;\r\n\r\n    if (props === this._oldProps || !this._group) {\r\n      return;\r\n    }\r\n\r\n    const {\r\n      opacity,\r\n      strokes,\r\n      strokeColor,\r\n      radicalColor = null\r\n    } = props;\r\n\r\n    if (opacity !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.opacity)) {\r\n      this._group.style.opacity = opacity.toString(); // MS browsers seem to have a bug where if SVG is set to display:none, it sometimes breaks.\r\n      // More info: https://github.com/chanind/hanzi-writer/issues/164\r\n      // this is just a perf improvement, so disable for MS browsers\r\n\r\n      if (!isMsBrowser) {\r\n        var _this$_oldProps2;\r\n\r\n        if (opacity === 0) {\r\n          this._group.style.display = 'none';\r\n        } else if (((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.opacity) === 0) {\r\n          this._group.style.removeProperty('display');\r\n        }\r\n      }\r\n    }\r\n\r\n    const colorsChanged = !this._oldProps || strokeColor !== this._oldProps.strokeColor || radicalColor !== this._oldProps.radicalColor;\r\n\r\n    if (colorsChanged || strokes !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.strokes)) {\r\n      for (let i = 0; i < this._strokeRenderers.length; i++) {\r\n        var _this$_oldProps4;\r\n\r\n        if (!colorsChanged && (_this$_oldProps4 = this._oldProps) !== null && _this$_oldProps4 !== void 0 && _this$_oldProps4.strokes && strokes[i] === this._oldProps.strokes[i]) {\r\n          continue;\r\n        }\r\n\r\n        this._strokeRenderers[i].render({\r\n          strokeColor,\r\n          radicalColor,\r\n          opacity: strokes[i].opacity,\r\n          displayPortion: strokes[i].displayPortion\r\n        });\r\n      }\r\n    }\r\n\r\n    this._oldProps = props;\r\n  }\r\n\r\n}\r\n\r\nclass UserStrokeRenderer {\r\n  constructor() {\r\n    this._oldProps = undefined;\r\n  }\r\n\r\n  mount(target) {\r\n    this._path = createElm('path');\r\n    target.svg.appendChild(this._path);\r\n  }\r\n\r\n  render(props) {\r\n    var _this$_oldProps, _this$_oldProps2, _this$_oldProps3, _this$_oldProps4;\r\n\r\n    if (!this._path || props === this._oldProps) {\r\n      return;\r\n    }\r\n\r\n    if (props.strokeColor !== ((_this$_oldProps = this._oldProps) === null || _this$_oldProps === void 0 ? void 0 : _this$_oldProps.strokeColor) || props.strokeWidth !== ((_this$_oldProps2 = this._oldProps) === null || _this$_oldProps2 === void 0 ? void 0 : _this$_oldProps2.strokeWidth)) {\r\n      const {\r\n        r,\r\n        g,\r\n        b,\r\n        a\r\n      } = props.strokeColor;\r\n      attrs(this._path, {\r\n        fill: 'none',\r\n        stroke: `rgba(${r},${g},${b},${a})`,\r\n        'stroke-width': props.strokeWidth.toString(),\r\n        'stroke-linecap': 'round',\r\n        'stroke-linejoin': 'round'\r\n      });\r\n    }\r\n\r\n    if (props.opacity !== ((_this$_oldProps3 = this._oldProps) === null || _this$_oldProps3 === void 0 ? void 0 : _this$_oldProps3.opacity)) {\r\n      attr(this._path, 'opacity', props.opacity.toString());\r\n    }\r\n\r\n    if (props.points !== ((_this$_oldProps4 = this._oldProps) === null || _this$_oldProps4 === void 0 ? void 0 : _this$_oldProps4.points)) {\r\n      attr(this._path, 'd', getPathString(props.points));\r\n    }\r\n\r\n    this._oldProps = props;\r\n  }\r\n\r\n  destroy() {\r\n    removeElm(this._path);\r\n  }\r\n\r\n}\r\n\r\nclass HanziWriterRenderer {\r\n  constructor(character, positioner) {\r\n    this._character = character;\r\n    this._positioner = positioner;\r\n    this._mainCharRenderer = new CharacterRenderer(character);\r\n    this._outlineCharRenderer = new CharacterRenderer(character);\r\n    this._highlightCharRenderer = new CharacterRenderer(character);\r\n    this._userStrokeRenderers = {};\r\n  }\r\n\r\n  mount(target) {\r\n    const positionedTarget = target.createSubRenderTarget();\r\n    const group = positionedTarget.svg;\r\n    const {\r\n      xOffset,\r\n      yOffset,\r\n      height,\r\n      scale\r\n    } = this._positioner;\r\n    attr(group, 'transform', `translate(${xOffset}, ${height - yOffset}) scale(${scale}, ${-1 * scale})`);\r\n\r\n    this._outlineCharRenderer.mount(positionedTarget);\r\n\r\n    this._mainCharRenderer.mount(positionedTarget);\r\n\r\n    this._highlightCharRenderer.mount(positionedTarget);\r\n\r\n    this._positionedTarget = positionedTarget;\r\n  }\r\n\r\n  render(props) {\r\n    const {\r\n      main,\r\n      outline,\r\n      highlight\r\n    } = props.character;\r\n    const {\r\n      outlineColor,\r\n      radicalColor,\r\n      highlightColor,\r\n      strokeColor,\r\n      drawingWidth,\r\n      drawingColor\r\n    } = props.options;\r\n\r\n    this._outlineCharRenderer.render({\r\n      opacity: outline.opacity,\r\n      strokes: outline.strokes,\r\n      strokeColor: outlineColor\r\n    });\r\n\r\n    this._mainCharRenderer.render({\r\n      opacity: main.opacity,\r\n      strokes: main.strokes,\r\n      strokeColor,\r\n      radicalColor: radicalColor\r\n    });\r\n\r\n    this._highlightCharRenderer.render({\r\n      opacity: highlight.opacity,\r\n      strokes: highlight.strokes,\r\n      strokeColor: highlightColor\r\n    });\r\n\r\n    const userStrokes = props.userStrokes || {};\r\n\r\n    for (const userStrokeId in this._userStrokeRenderers) {\r\n      if (!userStrokes[userStrokeId]) {\r\n        var _this$_userStrokeRend;\r\n\r\n        (_this$_userStrokeRend = this._userStrokeRenderers[userStrokeId]) === null || _this$_userStrokeRend === void 0 ? void 0 : _this$_userStrokeRend.destroy();\r\n        delete this._userStrokeRenderers[userStrokeId];\r\n      }\r\n    }\r\n\r\n    for (const userStrokeId in userStrokes) {\r\n      const stroke = userStrokes[userStrokeId];\r\n\r\n      if (!stroke) {\r\n        continue;\r\n      }\r\n\r\n      const userStrokeProps = {\r\n        strokeWidth: drawingWidth,\r\n        strokeColor: drawingColor,\r\n        ...stroke\r\n      };\r\n\r\n      const strokeRenderer = (() => {\r\n        if (this._userStrokeRenderers[userStrokeId]) {\r\n          return this._userStrokeRenderers[userStrokeId];\r\n        }\r\n\r\n        const newStrokeRenderer = new UserStrokeRenderer();\r\n        newStrokeRenderer.mount(this._positionedTarget);\r\n        this._userStrokeRenderers[userStrokeId] = newStrokeRenderer;\r\n        return newStrokeRenderer;\r\n      })();\r\n\r\n      strokeRenderer.render(userStrokeProps);\r\n    }\r\n  }\r\n\r\n  destroy() {\r\n    removeElm(this._positionedTarget.svg);\r\n    this._positionedTarget.defs.innerHTML = '';\r\n  }\r\n\r\n}\r\n\r\n/** Generic render target */\r\nclass RenderTargetBase {\r\n  constructor(node) {\r\n    this.node = node;\r\n  }\r\n\r\n  addPointerStartListener(callback) {\r\n    this.node.addEventListener('mousedown', evt => {\r\n      callback(this._eventify(evt, this._getMousePoint));\r\n    });\r\n    this.node.addEventListener('touchstart', evt => {\r\n      callback(this._eventify(evt, this._getTouchPoint));\r\n    });\r\n  }\r\n\r\n  addPointerMoveListener(callback) {\r\n    this.node.addEventListener('mousemove', evt => {\r\n      callback(this._eventify(evt, this._getMousePoint));\r\n    });\r\n    this.node.addEventListener('touchmove', evt => {\r\n      callback(this._eventify(evt, this._getTouchPoint));\r\n    });\r\n  }\r\n\r\n  addPointerEndListener(callback) {\r\n    // TODO: find a way to not need global listeners\r\n    document.addEventListener('mouseup', callback);\r\n    document.addEventListener('touchend', callback);\r\n  }\r\n\r\n  getBoundingClientRect() {\r\n    return this.node.getBoundingClientRect();\r\n  }\r\n\r\n  updateDimensions(width, height) {\r\n    this.node.setAttribute('width', `${width}`);\r\n    this.node.setAttribute('height', `${height}`);\r\n  }\r\n\r\n  _eventify(evt, pointFunc) {\r\n    return {\r\n      getPoint: () => pointFunc.call(this, evt),\r\n      preventDefault: () => evt.preventDefault()\r\n    };\r\n  }\r\n\r\n  _getMousePoint(evt) {\r\n    const {\r\n      left,\r\n      top\r\n    } = this.getBoundingClientRect();\r\n    const x = evt.clientX - left;\r\n    const y = evt.clientY - top;\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n\r\n  _getTouchPoint(evt) {\r\n    const {\r\n      left,\r\n      top\r\n    } = this.getBoundingClientRect();\r\n    const x = evt.touches[0].clientX - left;\r\n    const y = evt.touches[0].clientY - top;\r\n    return {\r\n      x,\r\n      y\r\n    };\r\n  }\r\n\r\n}\r\n\r\nclass RenderTarget extends RenderTargetBase {\r\n  constructor(svg, defs) {\r\n    super(svg);\r\n    this.svg = svg;\r\n    this.defs = defs;\r\n\r\n    if ('createSVGPoint' in svg) {\r\n      this._pt = svg.createSVGPoint();\r\n    }\r\n  }\r\n\r\n  static init(elmOrId, width = '100%', height = '100%') {\r\n    const element = (() => {\r\n      if (typeof elmOrId === 'string') {\r\n        return document.getElementById(elmOrId);\r\n      }\r\n\r\n      return elmOrId;\r\n    })();\r\n\r\n    if (!element) {\r\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\r\n    }\r\n\r\n    const nodeType = element.nodeName.toUpperCase();\r\n\r\n    const svg = (() => {\r\n      if (nodeType === 'SVG' || nodeType === 'G') {\r\n        return element;\r\n      } else {\r\n        const svg = createElm('svg');\r\n        element.appendChild(svg);\r\n        return svg;\r\n      }\r\n    })();\r\n\r\n    attrs(svg, {\r\n      width,\r\n      height\r\n    });\r\n    const defs = createElm('defs');\r\n    svg.appendChild(defs);\r\n    return new RenderTarget(svg, defs);\r\n  }\r\n\r\n  createSubRenderTarget() {\r\n    const group = createElm('g');\r\n    this.svg.appendChild(group);\r\n    return new RenderTarget(group, this.defs);\r\n  }\r\n\r\n  _getMousePoint(evt) {\r\n    if (this._pt) {\r\n      this._pt.x = evt.clientX;\r\n      this._pt.y = evt.clientY;\r\n\r\n      if ('getScreenCTM' in this.node) {\r\n        var _this$node$getScreenC;\r\n\r\n        const localPt = this._pt.matrixTransform((_this$node$getScreenC = this.node.getScreenCTM()) === null || _this$node$getScreenC === void 0 ? void 0 : _this$node$getScreenC.inverse());\r\n\r\n        return {\r\n          x: localPt.x,\r\n          y: localPt.y\r\n        };\r\n      }\r\n    }\r\n\r\n    return super._getMousePoint.call(this, evt);\r\n  }\r\n\r\n  _getTouchPoint(evt) {\r\n    if (this._pt) {\r\n      this._pt.x = evt.touches[0].clientX;\r\n      this._pt.y = evt.touches[0].clientY;\r\n\r\n      if ('getScreenCTM' in this.node) {\r\n        var _this$node$getScreenC2;\r\n\r\n        const localPt = this._pt.matrixTransform((_this$node$getScreenC2 = this.node.getScreenCTM()) === null || _this$node$getScreenC2 === void 0 ? void 0 : _this$node$getScreenC2.inverse());\r\n\r\n        return {\r\n          x: localPt.x,\r\n          y: localPt.y\r\n        };\r\n      }\r\n    }\r\n\r\n    return super._getTouchPoint(evt);\r\n  }\r\n\r\n}\r\n\r\nvar svgRenderer = {\r\n  HanziWriterRenderer,\r\n  createRenderTarget: RenderTarget.init\r\n};\r\n\r\nconst drawPath = (ctx, points) => {\r\n  ctx.beginPath();\r\n  const start = points[0];\r\n  const remainingPoints = points.slice(1);\r\n  ctx.moveTo(start.x, start.y);\r\n\r\n  for (const point of remainingPoints) {\r\n    ctx.lineTo(point.x, point.y);\r\n  }\r\n\r\n  ctx.stroke();\r\n};\r\n/**\r\n * Break a path string into a series of canvas path commands\r\n *\r\n * Note: only works with the subset of SVG paths used by MakeMeAHanzi data\r\n * @param pathString\r\n */\r\n\r\nconst pathStringToCanvas = pathString => {\r\n  const pathParts = pathString.split(/(^|\\s+)(?=[A-Z])/).filter(part => part !== ' ');\r\n  const commands = [ctx => ctx.beginPath()];\r\n\r\n  for (const part of pathParts) {\r\n    const [cmd, ...rawParams] = part.split(/\\s+/);\r\n    const params = rawParams.map(param => parseFloat(param));\r\n\r\n    if (cmd === 'M') {\r\n      commands.push(ctx => ctx.moveTo(...params));\r\n    } else if (cmd === 'L') {\r\n      commands.push(ctx => ctx.lineTo(...params));\r\n    } else if (cmd === 'C') {\r\n      commands.push(ctx => ctx.bezierCurveTo(...params));\r\n    } else if (cmd === 'Q') {\r\n      commands.push(ctx => ctx.quadraticCurveTo(...params));\r\n    } else ;\r\n  }\r\n\r\n  return ctx => commands.forEach(cmd => cmd(ctx));\r\n};\r\n\r\n/** this is a stroke composed of several stroke parts */\r\n\r\nclass StrokeRenderer$1 extends StrokeRendererBase {\r\n  constructor(stroke, usePath2D = true) {\r\n    super(stroke);\r\n\r\n    if (usePath2D && Path2D) {\r\n      this._path2D = new Path2D(this.stroke.path);\r\n    } else {\r\n      this._pathCmd = pathStringToCanvas(this.stroke.path);\r\n    }\r\n\r\n    this._extendedMaskPoints = extendStart(this.stroke.points, StrokeRendererBase.STROKE_WIDTH / 2);\r\n  }\r\n\r\n  render(ctx, props) {\r\n    if (props.opacity < 0.05) {\r\n      return;\r\n    }\r\n\r\n    ctx.save();\r\n\r\n    if (this._path2D) {\r\n      ctx.clip(this._path2D);\r\n    } else {\r\n      var _this$_pathCmd;\r\n\r\n      (_this$_pathCmd = this._pathCmd) === null || _this$_pathCmd === void 0 ? void 0 : _this$_pathCmd.call(this, ctx); // wechat bugs out if the clip path isn't stroked or filled\r\n\r\n      ctx.globalAlpha = 0;\r\n      ctx.stroke();\r\n      ctx.clip();\r\n    }\r\n\r\n    const {\r\n      r,\r\n      g,\r\n      b,\r\n      a\r\n    } = this._getColor(props);\r\n\r\n    const color = a === 1 ? `rgb(${r},${g},${b})` : `rgb(${r},${g},${b},${a})`;\r\n\r\n    const dashOffset = this._getStrokeDashoffset(props.displayPortion);\r\n\r\n    ctx.globalAlpha = props.opacity;\r\n    ctx.strokeStyle = color;\r\n    ctx.fillStyle = color;\r\n    ctx.lineWidth = StrokeRendererBase.STROKE_WIDTH;\r\n    ctx.lineCap = 'round';\r\n    ctx.lineJoin = 'round'; // wechat sets dashOffset as a second param here. Should be harmless for browsers to add here too\r\n    // @ts-ignore\r\n\r\n    ctx.setLineDash([this._pathLength, this._pathLength], dashOffset);\r\n    ctx.lineDashOffset = dashOffset;\r\n    drawPath(ctx, this._extendedMaskPoints);\r\n    ctx.restore();\r\n  }\r\n\r\n}\r\n\r\nclass CharacterRenderer$1 {\r\n  constructor(character) {\r\n    this._strokeRenderers = character.strokes.map(stroke => new StrokeRenderer$1(stroke));\r\n  }\r\n\r\n  render(ctx, props) {\r\n    if (props.opacity < 0.05) return;\r\n    const {\r\n      opacity,\r\n      strokeColor,\r\n      radicalColor,\r\n      strokes\r\n    } = props;\r\n\r\n    for (let i = 0; i < this._strokeRenderers.length; i++) {\r\n      this._strokeRenderers[i].render(ctx, {\r\n        strokeColor,\r\n        radicalColor,\r\n        opacity: strokes[i].opacity * opacity,\r\n        displayPortion: strokes[i].displayPortion || 0\r\n      });\r\n    }\r\n  }\r\n\r\n}\r\n\r\nfunction renderUserStroke(ctx, props) {\r\n  if (props.opacity < 0.05) {\r\n    return;\r\n  }\r\n\r\n  const {\r\n    opacity,\r\n    strokeWidth,\r\n    strokeColor,\r\n    points\r\n  } = props;\r\n  const {\r\n    r,\r\n    g,\r\n    b,\r\n    a\r\n  } = strokeColor;\r\n  ctx.save();\r\n  ctx.globalAlpha = opacity;\r\n  ctx.lineWidth = strokeWidth;\r\n  ctx.strokeStyle = `rgba(${r},${g},${b},${a})`;\r\n  ctx.lineCap = 'round';\r\n  ctx.lineJoin = 'round';\r\n  drawPath(ctx, points);\r\n  ctx.restore();\r\n}\r\n\r\nclass HanziWriterRenderer$1 {\r\n  constructor(character, positioner) {\r\n    this.destroy = noop;\r\n    this._character = character;\r\n    this._positioner = positioner;\r\n    this._mainCharRenderer = new CharacterRenderer$1(character);\r\n    this._outlineCharRenderer = new CharacterRenderer$1(character);\r\n    this._highlightCharRenderer = new CharacterRenderer$1(character);\r\n  }\r\n\r\n  mount(target) {\r\n    this._target = target;\r\n  }\r\n\r\n  _animationFrame(cb) {\r\n    const {\r\n      width,\r\n      height,\r\n      scale,\r\n      xOffset,\r\n      yOffset\r\n    } = this._positioner;\r\n\r\n    const ctx = this._target.getContext();\r\n\r\n    ctx.clearRect(0, 0, width, height);\r\n    ctx.save();\r\n    ctx.translate(xOffset, height - yOffset);\r\n    ctx.transform(1, 0, 0, -1, 0, 0);\r\n    ctx.scale(scale, scale);\r\n    cb(ctx);\r\n    ctx.restore(); // @ts-expect-error Verify if this is still needed for the \"wechat miniprogram\".\r\n\r\n    if (ctx.draw) {\r\n      // @ts-expect-error\r\n      ctx.draw();\r\n    }\r\n  }\r\n\r\n  render(props) {\r\n    const {\r\n      outline,\r\n      main,\r\n      highlight\r\n    } = props.character;\r\n    const {\r\n      outlineColor,\r\n      strokeColor,\r\n      radicalColor,\r\n      highlightColor,\r\n      drawingColor,\r\n      drawingWidth\r\n    } = props.options;\r\n\r\n    this._animationFrame(ctx => {\r\n      this._outlineCharRenderer.render(ctx, {\r\n        opacity: outline.opacity,\r\n        strokes: outline.strokes,\r\n        strokeColor: outlineColor\r\n      });\r\n\r\n      this._mainCharRenderer.render(ctx, {\r\n        opacity: main.opacity,\r\n        strokes: main.strokes,\r\n        strokeColor: strokeColor,\r\n        radicalColor: radicalColor\r\n      });\r\n\r\n      this._highlightCharRenderer.render(ctx, {\r\n        opacity: highlight.opacity,\r\n        strokes: highlight.strokes,\r\n        strokeColor: highlightColor\r\n      });\r\n\r\n      const userStrokes = props.userStrokes || {};\r\n\r\n      for (const userStrokeId in userStrokes) {\r\n        const userStroke = userStrokes[userStrokeId];\r\n\r\n        if (userStroke) {\r\n          const userStrokeProps = {\r\n            strokeWidth: drawingWidth,\r\n            strokeColor: drawingColor,\r\n            ...userStroke\r\n          };\r\n          renderUserStroke(ctx, userStrokeProps);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\r\nclass RenderTarget$1 extends RenderTargetBase {\r\n  constructor(canvas) {\r\n    super(canvas);\r\n  }\r\n\r\n  static init(elmOrId, width = '100%', height = '100%') {\r\n    const element = (() => {\r\n      if (typeof elmOrId === 'string') {\r\n        return document.getElementById(elmOrId);\r\n      }\r\n\r\n      return elmOrId;\r\n    })();\r\n\r\n    if (!element) {\r\n      throw new Error(`HanziWriter target element not found: ${elmOrId}`);\r\n    }\r\n\r\n    const nodeType = element.nodeName.toUpperCase();\r\n\r\n    const canvas = (() => {\r\n      if (nodeType === 'CANVAS') {\r\n        return element;\r\n      }\r\n\r\n      const canvas = document.createElement('canvas');\r\n      element.appendChild(canvas);\r\n      return canvas;\r\n    })();\r\n\r\n    canvas.setAttribute('width', width);\r\n    canvas.setAttribute('height', height);\r\n    return new RenderTarget$1(canvas);\r\n  }\r\n\r\n  getContext() {\r\n    return this.node.getContext('2d');\r\n  }\r\n\r\n}\r\n\r\nvar canvasRenderer = {\r\n  HanziWriterRenderer: HanziWriterRenderer$1,\r\n  createRenderTarget: RenderTarget$1.init\r\n};\r\n\r\nconst VERSION = '2.0';\r\n\r\nconst getCharDataUrl = char => `https://cdn.jsdelivr.net/npm/hanzi-writer-data@${VERSION}/${char}.json`;\r\n\r\nconst defaultCharDataLoader = (char, onLoad, onError) => {\r\n  // load char data from hanziwriter cdn (currently hosted on jsdelivr)\r\n  const xhr = new XMLHttpRequest();\r\n\r\n  if (xhr.overrideMimeType) {\r\n    // IE 9 and 10 don't seem to support this...\r\n    xhr.overrideMimeType('application/json');\r\n  }\r\n\r\n  xhr.open('GET', getCharDataUrl(char), true);\r\n\r\n  xhr.onerror = event => {\r\n    onError(xhr, event);\r\n  };\r\n\r\n  xhr.onreadystatechange = () => {\r\n    // TODO: error handling\r\n    if (xhr.readyState !== 4) return;\r\n\r\n    if (xhr.status === 200) {\r\n      onLoad(JSON.parse(xhr.responseText));\r\n    } else if (xhr.status !== 0 && onError) {\r\n      onError(xhr);\r\n    }\r\n  };\r\n\r\n  xhr.send(null);\r\n};\r\n\r\nconst defaultOptions = {\r\n  charDataLoader: defaultCharDataLoader,\r\n  onLoadCharDataError: null,\r\n  onLoadCharDataSuccess: null,\r\n  showOutline: true,\r\n  showCharacter: true,\r\n  renderer: 'svg',\r\n  // positioning options\r\n  width: 0,\r\n  height: 0,\r\n  padding: 20,\r\n  // animation options\r\n  strokeAnimationSpeed: 1,\r\n  strokeFadeDuration: 400,\r\n  strokeHighlightDuration: 200,\r\n  strokeHighlightSpeed: 2,\r\n  delayBetweenStrokes: 1000,\r\n  delayBetweenLoops: 2000,\r\n  // colors\r\n  strokeColor: '#555',\r\n  radicalColor: null,\r\n  highlightColor: '#AAF',\r\n  outlineColor: '#DDD',\r\n  drawingColor: '#333',\r\n  // quiz options\r\n  leniency: 1,\r\n  showHintAfterMisses: 3,\r\n  highlightOnComplete: true,\r\n  highlightCompleteColor: null,\r\n  markStrokeCorrectAfterMisses: false,\r\n  acceptBackwardsStrokes: false,\r\n  quizStartStrokeNum: 0,\r\n  averageDistanceThreshold: 350,\r\n  // undocumented obscure options\r\n  drawingFadeDuration: 300,\r\n  drawingWidth: 4,\r\n  strokeWidth: 2,\r\n  outlineWidth: 2,\r\n  rendererOverride: {}\r\n};\r\n\r\nclass LoadingManager {\r\n  constructor(options) {\r\n    this._loadCounter = 0;\r\n    this._isLoading = false;\r\n    /** use this to attribute to determine if there was a problem with loading */\r\n\r\n    this.loadingFailed = false;\r\n    this._options = options;\r\n  }\r\n\r\n  _debouncedLoad(char, count) {\r\n    // these wrappers ignore all responses except the most recent.\r\n    const wrappedResolve = data => {\r\n      if (count === this._loadCounter) {\r\n        var _this$_resolve;\r\n\r\n        (_this$_resolve = this._resolve) === null || _this$_resolve === void 0 ? void 0 : _this$_resolve.call(this, data);\r\n      }\r\n    };\r\n\r\n    const wrappedReject = reason => {\r\n      if (count === this._loadCounter) {\r\n        var _this$_reject;\r\n\r\n        (_this$_reject = this._reject) === null || _this$_reject === void 0 ? void 0 : _this$_reject.call(this, reason);\r\n      }\r\n    };\r\n\r\n    const returnedData = this._options.charDataLoader(char, wrappedResolve, wrappedReject);\r\n\r\n    if (returnedData) {\r\n      if ('then' in returnedData) {\r\n        returnedData.then(wrappedResolve).catch(wrappedReject);\r\n      } else {\r\n        wrappedResolve(returnedData);\r\n      }\r\n    }\r\n  }\r\n\r\n  _setupLoadingPromise() {\r\n    return new Promise((resolve, reject) => {\r\n      this._resolve = resolve;\r\n      this._reject = reject;\r\n    }).then(data => {\r\n      var _this$_options$onLoad, _this$_options;\r\n\r\n      this._isLoading = false;\r\n      (_this$_options$onLoad = (_this$_options = this._options).onLoadCharDataSuccess) === null || _this$_options$onLoad === void 0 ? void 0 : _this$_options$onLoad.call(_this$_options, data);\r\n      return data;\r\n    }).catch(reason => {\r\n      this._isLoading = false;\r\n      this.loadingFailed = true; // If the user has provided an \"onLoadCharDataError\", call this function\r\n      // Otherwise, throw the promise\r\n\r\n      if (this._options.onLoadCharDataError) {\r\n        this._options.onLoadCharDataError(reason);\r\n\r\n        return;\r\n      } // If error callback wasn't provided, throw an error so the developer will be aware something went wrong\r\n\r\n\r\n      if (reason instanceof Error) {\r\n        throw reason;\r\n      }\r\n\r\n      const err = new Error(`Failed to load char data for ${this._loadingChar}`);\r\n      err.reason = reason;\r\n      throw err;\r\n    });\r\n  }\r\n\r\n  loadCharData(char) {\r\n    this._loadingChar = char;\r\n\r\n    const promise = this._setupLoadingPromise();\r\n\r\n    this.loadingFailed = false;\r\n    this._isLoading = true;\r\n    this._loadCounter++;\r\n\r\n    this._debouncedLoad(char, this._loadCounter);\r\n\r\n    return promise;\r\n  }\r\n\r\n}\r\n\r\nclass HanziWriter {\r\n  constructor(element, options = {}) {\r\n    const {\r\n      HanziWriterRenderer,\r\n      createRenderTarget\r\n    } = options.renderer === 'canvas' ? canvasRenderer : svgRenderer;\r\n    const rendererOverride = options.rendererOverride || {};\r\n    this._renderer = {\r\n      HanziWriterRenderer: rendererOverride.HanziWriterRenderer || HanziWriterRenderer,\r\n      createRenderTarget: rendererOverride.createRenderTarget || createRenderTarget\r\n    }; // wechat miniprogram component needs direct access to the render target, so this is public\r\n\r\n    this.target = this._renderer.createRenderTarget(element, options.width, options.height);\r\n    this._options = this._assignOptions(options);\r\n    this._loadingManager = new LoadingManager(this._options);\r\n\r\n    this._setupListeners();\r\n  }\r\n  /** Main entry point */\r\n\r\n\r\n  static create(element, character, options) {\r\n    const writer = new HanziWriter(element, options);\r\n    writer.setCharacter(character);\r\n    return writer;\r\n  }\r\n\r\n  static loadCharacterData(character, options = {}) {\r\n    const loadingManager = (() => {\r\n      const {\r\n        _loadingManager,\r\n        _loadingOptions\r\n      } = HanziWriter;\r\n\r\n      if ((_loadingManager === null || _loadingManager === void 0 ? void 0 : _loadingManager._loadingChar) === character && _loadingOptions === options) {\r\n        return _loadingManager;\r\n      }\r\n\r\n      return new LoadingManager({ ...defaultOptions,\r\n        ...options\r\n      });\r\n    })();\r\n\r\n    HanziWriter._loadingManager = loadingManager;\r\n    HanziWriter._loadingOptions = options;\r\n    return loadingManager.loadCharData(character);\r\n  }\r\n\r\n  static getScalingTransform(width, height, padding = 0) {\r\n    const positioner = new Positioner({\r\n      width,\r\n      height,\r\n      padding\r\n    });\r\n    return {\r\n      x: positioner.xOffset,\r\n      y: positioner.yOffset,\r\n      scale: positioner.scale,\r\n      transform: trim(`\r\n        translate(${positioner.xOffset}, ${positioner.height - positioner.yOffset})\r\n        scale(${positioner.scale}, ${-1 * positioner.scale})\r\n      `).replace(/\\s+/g, ' ')\r\n    };\r\n  }\r\n\r\n  showCharacter(options = {}) {\r\n    this._options.showCharacter = true;\r\n    return this._withData(() => {\r\n      var _this$_renderState;\r\n\r\n      return (_this$_renderState = this._renderState) === null || _this$_renderState === void 0 ? void 0 : _this$_renderState.run(showCharacter('main', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\r\n        var _options$onComplete;\r\n\r\n        (_options$onComplete = options.onComplete) === null || _options$onComplete === void 0 ? void 0 : _options$onComplete.call(options, res);\r\n        return res;\r\n      });\r\n    });\r\n  }\r\n\r\n  hideCharacter(options = {}) {\r\n    this._options.showCharacter = false;\r\n    return this._withData(() => {\r\n      var _this$_renderState2;\r\n\r\n      return (_this$_renderState2 = this._renderState) === null || _this$_renderState2 === void 0 ? void 0 : _this$_renderState2.run(hideCharacter('main', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\r\n        var _options$onComplete2;\r\n\r\n        (_options$onComplete2 = options.onComplete) === null || _options$onComplete2 === void 0 ? void 0 : _options$onComplete2.call(options, res);\r\n        return res;\r\n      });\r\n    });\r\n  }\r\n\r\n  animateCharacter(options = {}) {\r\n    this.cancelQuiz();\r\n    return this._withData(() => {\r\n      var _this$_renderState3;\r\n\r\n      return (_this$_renderState3 = this._renderState) === null || _this$_renderState3 === void 0 ? void 0 : _this$_renderState3.run(animateCharacter('main', this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes)).then(res => {\r\n        var _options$onComplete3;\r\n\r\n        (_options$onComplete3 = options.onComplete) === null || _options$onComplete3 === void 0 ? void 0 : _options$onComplete3.call(options, res);\r\n        return res;\r\n      });\r\n    });\r\n  }\r\n\r\n  animateStroke(strokeNum, options = {}) {\r\n    this.cancelQuiz();\r\n    return this._withData(() => {\r\n      var _this$_renderState4;\r\n\r\n      return (_this$_renderState4 = this._renderState) === null || _this$_renderState4 === void 0 ? void 0 : _this$_renderState4.run(animateSingleStroke('main', this._character, fixIndex(strokeNum, this._character.strokes.length), this._options.strokeAnimationSpeed)).then(res => {\r\n        var _options$onComplete4;\r\n\r\n        (_options$onComplete4 = options.onComplete) === null || _options$onComplete4 === void 0 ? void 0 : _options$onComplete4.call(options, res);\r\n        return res;\r\n      });\r\n    });\r\n  }\r\n\r\n  highlightStroke(strokeNum, options = {}) {\r\n    const promise = () => {\r\n      if (!this._character || !this._renderState) {\r\n        return;\r\n      }\r\n\r\n      return this._renderState.run(highlightStroke(selectIndex(this._character.strokes, strokeNum), colorStringToVals(this._options.highlightColor), this._options.strokeHighlightSpeed)).then(res => {\r\n        var _options$onComplete5;\r\n\r\n        (_options$onComplete5 = options.onComplete) === null || _options$onComplete5 === void 0 ? void 0 : _options$onComplete5.call(options, res);\r\n        return res;\r\n      });\r\n    };\r\n\r\n    return this._withData(promise);\r\n  }\r\n\r\n  async loopCharacterAnimation() {\r\n    this.cancelQuiz();\r\n    return this._withData(() => this._renderState.run(animateCharacterLoop('main', this._character, this._options.strokeFadeDuration, this._options.strokeAnimationSpeed, this._options.delayBetweenStrokes, this._options.delayBetweenLoops), {\r\n      loop: true\r\n    }));\r\n  }\r\n\r\n  pauseAnimation() {\r\n    return this._withData(() => {\r\n      var _this$_renderState5;\r\n\r\n      return (_this$_renderState5 = this._renderState) === null || _this$_renderState5 === void 0 ? void 0 : _this$_renderState5.pauseAll();\r\n    });\r\n  }\r\n\r\n  resumeAnimation() {\r\n    return this._withData(() => {\r\n      var _this$_renderState6;\r\n\r\n      return (_this$_renderState6 = this._renderState) === null || _this$_renderState6 === void 0 ? void 0 : _this$_renderState6.resumeAll();\r\n    });\r\n  }\r\n\r\n  showOutline(options = {}) {\r\n    this._options.showOutline = true;\r\n    return this._withData(() => {\r\n      var _this$_renderState7;\r\n\r\n      return (_this$_renderState7 = this._renderState) === null || _this$_renderState7 === void 0 ? void 0 : _this$_renderState7.run(showCharacter('outline', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\r\n        var _options$onComplete6;\r\n\r\n        (_options$onComplete6 = options.onComplete) === null || _options$onComplete6 === void 0 ? void 0 : _options$onComplete6.call(options, res);\r\n        return res;\r\n      });\r\n    });\r\n  }\r\n\r\n  hideOutline(options = {}) {\r\n    this._options.showOutline = false;\r\n    return this._withData(() => {\r\n      var _this$_renderState8;\r\n\r\n      return (_this$_renderState8 = this._renderState) === null || _this$_renderState8 === void 0 ? void 0 : _this$_renderState8.run(hideCharacter('outline', this._character, typeof options.duration === 'number' ? options.duration : this._options.strokeFadeDuration)).then(res => {\r\n        var _options$onComplete7;\r\n\r\n        (_options$onComplete7 = options.onComplete) === null || _options$onComplete7 === void 0 ? void 0 : _options$onComplete7.call(options, res);\r\n        return res;\r\n      });\r\n    });\r\n  }\r\n  /** Updates the size of the writer instance without resetting render state */\r\n\r\n\r\n  updateDimensions({\r\n    width,\r\n    height,\r\n    padding\r\n  }) {\r\n    if (width !== undefined) this._options.width = width;\r\n    if (height !== undefined) this._options.height = height;\r\n    if (padding !== undefined) this._options.padding = padding;\r\n    this.target.updateDimensions(this._options.width, this._options.height); // if there's already a character drawn, destroy and recreate the renderer in the same state\r\n\r\n    if (this._character && this._renderState && this._hanziWriterRenderer && this._positioner) {\r\n      this._hanziWriterRenderer.destroy();\r\n\r\n      const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(this._character); // TODO: this should probably implement EventEmitter instead of manually tracking updates like this\r\n\r\n\r\n      this._renderState.overwriteOnStateChange(nextState => hanziWriterRenderer.render(nextState));\r\n\r\n      hanziWriterRenderer.render(this._renderState.state); // update the current quiz as well, if one is active\r\n\r\n      if (this._quiz) {\r\n        this._quiz.setPositioner(this._positioner);\r\n      }\r\n    }\r\n  }\r\n\r\n  updateColor(colorName, colorVal, options = {}) {\r\n    var _options$duration;\r\n\r\n    let mutations = [];\r\n\r\n    const fixedColorVal = (() => {\r\n      // If we're removing radical color, tween it to the stroke color\r\n      if (colorName === 'radicalColor' && !colorVal) {\r\n        return this._options.strokeColor;\r\n      }\r\n\r\n      return colorVal;\r\n    })();\r\n\r\n    const mappedColor = colorStringToVals(fixedColorVal);\r\n    this._options[colorName] = colorVal;\r\n    const duration = (_options$duration = options.duration) !== null && _options$duration !== void 0 ? _options$duration : this._options.strokeFadeDuration;\r\n    mutations = mutations.concat(updateColor(colorName, mappedColor, duration)); // make sure to set radicalColor back to null after the transition finishes if val == null\r\n\r\n    if (colorName === 'radicalColor' && !colorVal) {\r\n      mutations = mutations.concat(updateColor(colorName, null, 0));\r\n    }\r\n\r\n    return this._withData(() => {\r\n      var _this$_renderState9;\r\n\r\n      return (_this$_renderState9 = this._renderState) === null || _this$_renderState9 === void 0 ? void 0 : _this$_renderState9.run(mutations).then(res => {\r\n        var _options$onComplete8;\r\n\r\n        (_options$onComplete8 = options.onComplete) === null || _options$onComplete8 === void 0 ? void 0 : _options$onComplete8.call(options, res);\r\n        return res;\r\n      });\r\n    });\r\n  }\r\n\r\n  quiz(quizOptions = {}) {\r\n    return this._withData(async () => {\r\n      if (this._character && this._renderState && this._positioner) {\r\n        this.cancelQuiz();\r\n        this._quiz = new Quiz(this._character, this._renderState, this._positioner);\r\n        this._options = { ...this._options,\r\n          ...quizOptions\r\n        };\r\n\r\n        this._quiz.startQuiz(this._options);\r\n      }\r\n    });\r\n  }\r\n\r\n  skipQuizStroke() {\r\n    if (this._quiz) {\r\n      this._quiz.nextStroke();\r\n    }\r\n  }\r\n\r\n  cancelQuiz() {\r\n    if (this._quiz) {\r\n      this._quiz.cancel();\r\n\r\n      this._quiz = undefined;\r\n    }\r\n  }\r\n\r\n  setCharacter(char) {\r\n    this.cancelQuiz();\r\n    this._char = char;\r\n\r\n    if (this._hanziWriterRenderer) {\r\n      this._hanziWriterRenderer.destroy();\r\n    }\r\n\r\n    if (this._renderState) {\r\n      this._renderState.cancelAll();\r\n    }\r\n\r\n    this._hanziWriterRenderer = null;\r\n    this._withDataPromise = this._loadingManager.loadCharData(char).then(pathStrings => {\r\n      // if \"pathStrings\" isn't set, \".catch()\"\" was probably called and loading likely failed\r\n      if (!pathStrings || this._loadingManager.loadingFailed) {\r\n        return;\r\n      }\r\n\r\n      this._character = parseCharData(char, pathStrings);\r\n      this._renderState = new RenderState(this._character, this._options, nextState => hanziWriterRenderer.render(nextState));\r\n\r\n      const hanziWriterRenderer = this._initAndMountHanziWriterRenderer(this._character);\r\n\r\n      hanziWriterRenderer.render(this._renderState.state);\r\n    });\r\n    return this._withDataPromise;\r\n  }\r\n\r\n  _initAndMountHanziWriterRenderer(character) {\r\n    const {\r\n      width,\r\n      height,\r\n      padding\r\n    } = this._options;\r\n    this._positioner = new Positioner({\r\n      width,\r\n      height,\r\n      padding\r\n    });\r\n    const hanziWriterRenderer = new this._renderer.HanziWriterRenderer(character, this._positioner);\r\n    hanziWriterRenderer.mount(this.target);\r\n    this._hanziWriterRenderer = hanziWriterRenderer;\r\n    return hanziWriterRenderer;\r\n  }\r\n\r\n  async getCharacterData() {\r\n    if (!this._char) {\r\n      throw new Error('setCharacter() must be called before calling getCharacterData()');\r\n    }\r\n\r\n    const character = await this._withData(() => this._character);\r\n    return character;\r\n  }\r\n\r\n  _assignOptions(options) {\r\n    const mergedOptions = { ...defaultOptions,\r\n      ...options\r\n    }; // backfill strokeAnimationSpeed if deprecated strokeAnimationDuration is provided instead\r\n\r\n    if (options.strokeAnimationDuration && !options.strokeAnimationSpeed) {\r\n      mergedOptions.strokeAnimationSpeed = 500 / options.strokeAnimationDuration;\r\n    }\r\n\r\n    if (options.strokeHighlightDuration && !options.strokeHighlightSpeed) {\r\n      mergedOptions.strokeHighlightSpeed = 500 / mergedOptions.strokeHighlightDuration;\r\n    }\r\n\r\n    if (!options.highlightCompleteColor) {\r\n      mergedOptions.highlightCompleteColor = mergedOptions.highlightColor;\r\n    }\r\n\r\n    return this._fillWidthAndHeight(mergedOptions);\r\n  }\r\n  /** returns a new options object with width and height filled in if missing */\r\n\r\n\r\n  _fillWidthAndHeight(options) {\r\n    const filledOpts = { ...options\r\n    };\r\n\r\n    if (filledOpts.width && !filledOpts.height) {\r\n      filledOpts.height = filledOpts.width;\r\n    } else if (filledOpts.height && !filledOpts.width) {\r\n      filledOpts.width = filledOpts.height;\r\n    } else if (!filledOpts.width && !filledOpts.height) {\r\n      const {\r\n        width,\r\n        height\r\n      } = this.target.getBoundingClientRect();\r\n      const minDim = Math.min(width, height);\r\n      filledOpts.width = minDim;\r\n      filledOpts.height = minDim;\r\n    }\r\n\r\n    return filledOpts;\r\n  }\r\n\r\n  _withData(func) {\r\n    // if this._loadingManager.loadingFailed, then loading failed before this method was called\r\n    if (this._loadingManager.loadingFailed) {\r\n      throw Error('Failed to load character data. Call setCharacter and try again.');\r\n    }\r\n\r\n    if (this._withDataPromise) {\r\n      return this._withDataPromise.then(() => {\r\n        if (!this._loadingManager.loadingFailed) {\r\n          return func();\r\n        }\r\n      });\r\n    }\r\n\r\n    return Promise.resolve().then(func);\r\n  }\r\n\r\n  _setupListeners() {\r\n    this.target.addPointerStartListener(evt => {\r\n      if (this._quiz) {\r\n        evt.preventDefault();\r\n\r\n        this._quiz.startUserStroke(evt.getPoint());\r\n      }\r\n    });\r\n    this.target.addPointerMoveListener(evt => {\r\n      if (this._quiz) {\r\n        evt.preventDefault();\r\n\r\n        this._quiz.continueUserStroke(evt.getPoint());\r\n      }\r\n    });\r\n    this.target.addPointerEndListener(() => {\r\n      var _this$_quiz;\r\n\r\n      (_this$_quiz = this._quiz) === null || _this$_quiz === void 0 ? void 0 : _this$_quiz.endUserStroke();\r\n    });\r\n  }\r\n\r\n}\r\n/** Singleton instance of LoadingManager. Only set in `loadCharacterData` */\r\n\r\nHanziWriter._loadingManager = null;\r\n/** Singleton loading options. Only set in `loadCharacterData` */\r\n\r\nHanziWriter._loadingOptions = null;\r\n\r\nmodule.exports = HanziWriter;\r\n//# sourceMappingURL=index.cjs.js.map\r\n"]}